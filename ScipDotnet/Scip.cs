// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: scip.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Scip {

  /// <summary>Holder for reflection information generated from scip.proto</summary>
  public static partial class ScipReflection {

    #region Descriptor
    /// <summary>File descriptor for scip.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ScipReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CgpzY2lwLnByb3RvEgRzY2lwIn8KBUluZGV4EiAKCG1ldGFkYXRhGAEgASgL",
            "Mg4uc2NpcC5NZXRhZGF0YRIhCglkb2N1bWVudHMYAiADKAsyDi5zY2lwLkRv",
            "Y3VtZW50EjEKEGV4dGVybmFsX3N5bWJvbHMYAyADKAsyFy5zY2lwLlN5bWJv",
            "bEluZm9ybWF0aW9uIp8BCghNZXRhZGF0YRImCgd2ZXJzaW9uGAEgASgOMhUu",
            "c2NpcC5Qcm90b2NvbFZlcnNpb24SIQoJdG9vbF9pbmZvGAIgASgLMg4uc2Np",
            "cC5Ub29sSW5mbxIUCgxwcm9qZWN0X3Jvb3QYAyABKAkSMgoWdGV4dF9kb2N1",
            "bWVudF9lbmNvZGluZxgEIAEoDjISLnNjaXAuVGV4dEVuY29kaW5nIjwKCFRv",
            "b2xJbmZvEgwKBG5hbWUYASABKAkSDwoHdmVyc2lvbhgCIAEoCRIRCglhcmd1",
            "bWVudHMYAyADKAkixQEKCERvY3VtZW50EhAKCGxhbmd1YWdlGAQgASgJEhUK",
            "DXJlbGF0aXZlX3BhdGgYASABKAkSJQoLb2NjdXJyZW5jZXMYAiADKAsyEC5z",
            "Y2lwLk9jY3VycmVuY2USKAoHc3ltYm9scxgDIAMoCzIXLnNjaXAuU3ltYm9s",
            "SW5mb3JtYXRpb24SDAoEdGV4dBgFIAEoCRIxChFwb3NpdGlvbl9lbmNvZGlu",
            "ZxgGIAEoDjIWLnNjaXAuUG9zaXRpb25FbmNvZGluZyJlCgZTeW1ib2wSDgoG",
            "c2NoZW1lGAEgASgJEh4KB3BhY2thZ2UYAiABKAsyDS5zY2lwLlBhY2thZ2US",
            "KwoLZGVzY3JpcHRvcnMYAyADKAsyFi5zY2lwLlN5bWJvbERlc2NyaXB0b3Ii",
            "OQoHUGFja2FnZRIPCgdtYW5hZ2VyGAEgASgJEgwKBG5hbWUYAiABKAkSDwoH",
            "dmVyc2lvbhgDIAEoCSKOAgoQU3ltYm9sRGVzY3JpcHRvchIMCgRuYW1lGAEg",
            "ASgJEhUKDWRpc2FtYmlndWF0b3IYAiABKAkSLQoGc3VmZml4GAMgASgOMh0u",
            "c2NpcC5TeW1ib2xEZXNjcmlwdG9yLlN1ZmZpeCKlAQoGU3VmZml4EhUKEVVu",
            "c3BlY2lmaWVkU3VmZml4EAASDQoJTmFtZXNwYWNlEAESDwoHUGFja2FnZRAB",
            "GgIIARIICgRUeXBlEAISCAoEVGVybRADEgoKBk1ldGhvZBAEEhEKDVR5cGVQ",
            "YXJhbWV0ZXIQBRINCglQYXJhbWV0ZXIQBhIICgRNZXRhEAcSCQoFTG9jYWwQ",
            "CBIJCgVNYWNybxAJGgIQASLwCwoRU3ltYm9sSW5mb3JtYXRpb24SDgoGc3lt",
            "Ym9sGAEgASgJEhUKDWRvY3VtZW50YXRpb24YAyADKAkSKQoNcmVsYXRpb25z",
            "aGlwcxgEIAMoCzISLnNjaXAuUmVsYXRpb25zaGlwEioKBGtpbmQYBSABKA4y",
            "HC5zY2lwLlN5bWJvbEluZm9ybWF0aW9uLktpbmQSFAoMZGlzcGxheV9uYW1l",
            "GAYgASgJEi8KF3NpZ25hdHVyZV9kb2N1bWVudGF0aW9uGAcgASgLMg4uc2Np",
            "cC5Eb2N1bWVudBIYChBlbmNsb3Npbmdfc3ltYm9sGAggASgJIvsJCgRLaW5k",
            "EhMKD1Vuc3BlY2lmaWVkS2luZBAAEhIKDkFic3RyYWN0TWV0aG9kEEISDAoI",
            "QWNjZXNzb3IQSBIJCgVBcnJheRABEg0KCUFzc2VydGlvbhACEhIKDkFzc29j",
            "aWF0ZWRUeXBlEAMSDQoJQXR0cmlidXRlEAQSCQoFQXhpb20QBRILCgdCb29s",
            "ZWFuEAYSCQoFQ2xhc3MQBxILCgdDb25jZXB0EFYSDAoIQ29uc3RhbnQQCBIP",
            "CgtDb25zdHJ1Y3RvchAJEgwKCENvbnRyYWN0ED4SDgoKRGF0YUZhbWlseRAK",
            "EgwKCERlbGVnYXRlEEkSCAoERW51bRALEg4KCkVudW1NZW1iZXIQDBIJCgVF",
            "cnJvchA/EgkKBUV2ZW50EA0SDQoJRXh0ZW5zaW9uEFQSCAoERmFjdBAOEgkK",
            "BUZpZWxkEA8SCAoERmlsZRAQEgwKCEZ1bmN0aW9uEBESCgoGR2V0dGVyEBIS",
            "CwoHR3JhbW1hchATEgwKCEluc3RhbmNlEBQSDQoJSW50ZXJmYWNlEBUSBwoD",
            "S2V5EBYSCAoETGFuZxAXEgkKBUxlbW1hEBgSCwoHTGlicmFyeRBAEgkKBU1h",
            "Y3JvEBkSCgoGTWV0aG9kEBoSDwoLTWV0aG9kQWxpYXMQShISCg5NZXRob2RS",
            "ZWNlaXZlchAbEhcKE01ldGhvZFNwZWNpZmljYXRpb24QQxILCgdNZXNzYWdl",
            "EBwSCQoFTWl4aW4QVRIMCghNb2RpZmllchBBEgoKBk1vZHVsZRAdEg0KCU5h",
            "bWVzcGFjZRAeEggKBE51bGwQHxIKCgZOdW1iZXIQIBIKCgZPYmplY3QQIRIM",
            "CghPcGVyYXRvchAiEgsKB1BhY2thZ2UQIxIRCg1QYWNrYWdlT2JqZWN0ECQS",
            "DQoJUGFyYW1ldGVyECUSEgoOUGFyYW1ldGVyTGFiZWwQJhILCgdQYXR0ZXJu",
            "ECcSDQoJUHJlZGljYXRlECgSDAoIUHJvcGVydHkQKRIMCghQcm90b2NvbBAq",
            "EhIKDlByb3RvY29sTWV0aG9kEEQSFQoRUHVyZVZpcnR1YWxNZXRob2QQRRIP",
            "CgtRdWFzaXF1b3RlchArEhEKDVNlbGZQYXJhbWV0ZXIQLBIKCgZTZXR0ZXIQ",
            "LRINCglTaWduYXR1cmUQLhISCg5TaW5nbGV0b25DbGFzcxBLEhMKD1Npbmds",
            "ZXRvbk1ldGhvZBBMEhQKEFN0YXRpY0RhdGFNZW1iZXIQTRIPCgtTdGF0aWNF",
            "dmVudBBOEg8KC1N0YXRpY0ZpZWxkEE8SEAoMU3RhdGljTWV0aG9kEFASEgoO",
            "U3RhdGljUHJvcGVydHkQURISCg5TdGF0aWNWYXJpYWJsZRBSEgoKBlN0cmlu",
            "ZxAwEgoKBlN0cnVjdBAxEg0KCVN1YnNjcmlwdBAvEgoKBlRhY3RpYxAyEgsK",
            "B1RoZW9yZW0QMxIRCg1UaGlzUGFyYW1ldGVyEDQSCQoFVHJhaXQQNRIPCgtU",
            "cmFpdE1ldGhvZBBGEggKBFR5cGUQNhINCglUeXBlQWxpYXMQNxINCglUeXBl",
            "Q2xhc3MQOBITCg9UeXBlQ2xhc3NNZXRob2QQRxIOCgpUeXBlRmFtaWx5EDkS",
            "EQoNVHlwZVBhcmFtZXRlchA6EgkKBVVuaW9uEDsSCQoFVmFsdWUQPBIMCghW",
            "YXJpYWJsZRA9IoIBCgxSZWxhdGlvbnNoaXASDgoGc3ltYm9sGAEgASgJEhQK",
            "DGlzX3JlZmVyZW5jZRgCIAEoCBIZChFpc19pbXBsZW1lbnRhdGlvbhgDIAEo",
            "CBIaChJpc190eXBlX2RlZmluaXRpb24YBCABKAgSFQoNaXNfZGVmaW5pdGlv",
            "bhgFIAEoCCLIAQoKT2NjdXJyZW5jZRINCgVyYW5nZRgBIAMoBRIOCgZzeW1i",
            "b2wYAiABKAkSFAoMc3ltYm9sX3JvbGVzGAMgASgFEh4KFm92ZXJyaWRlX2Rv",
            "Y3VtZW50YXRpb24YBCADKAkSJQoLc3ludGF4X2tpbmQYBSABKA4yEC5zY2lw",
            "LlN5bnRheEtpbmQSJQoLZGlhZ25vc3RpY3MYBiADKAsyEC5zY2lwLkRpYWdu",
            "b3N0aWMSFwoPZW5jbG9zaW5nX3JhbmdlGAcgAygFIoABCgpEaWFnbm9zdGlj",
            "EiAKCHNldmVyaXR5GAEgASgOMg4uc2NpcC5TZXZlcml0eRIMCgRjb2RlGAIg",
            "ASgJEg8KB21lc3NhZ2UYAyABKAkSDgoGc291cmNlGAQgASgJEiEKBHRhZ3MY",
            "BSADKA4yEy5zY2lwLkRpYWdub3N0aWNUYWcqMQoPUHJvdG9jb2xWZXJzaW9u",
            "Eh4KGlVuc3BlY2lmaWVkUHJvdG9jb2xWZXJzaW9uEAAqQAoMVGV4dEVuY29k",
            "aW5nEhsKF1Vuc3BlY2lmaWVkVGV4dEVuY29kaW5nEAASCAoEVVRGOBABEgkK",
            "BVVURjE2EAIqpAEKEFBvc2l0aW9uRW5jb2RpbmcSHwobVW5zcGVjaWZpZWRQ",
            "b3NpdGlvbkVuY29kaW5nEAASIwofVVRGOENvZGVVbml0T2Zmc2V0RnJvbUxp",
            "bmVTdGFydBABEiQKIFVURjE2Q29kZVVuaXRPZmZzZXRGcm9tTGluZVN0YXJ0",
            "EAISJAogVVRGMzJDb2RlVW5pdE9mZnNldEZyb21MaW5lU3RhcnQQAyqUAQoK",
            "U3ltYm9sUm9sZRIZChVVbnNwZWNpZmllZFN5bWJvbFJvbGUQABIOCgpEZWZp",
            "bml0aW9uEAESCgoGSW1wb3J0EAISDwoLV3JpdGVBY2Nlc3MQBBIOCgpSZWFk",
            "QWNjZXNzEAgSDQoJR2VuZXJhdGVkEBASCAoEVGVzdBAgEhUKEUZvcndhcmRE",
            "ZWZpbml0aW9uEEAq6gYKClN5bnRheEtpbmQSGQoVVW5zcGVjaWZpZWRTeW50",
            "YXhLaW5kEAASCwoHQ29tbWVudBABEhgKFFB1bmN0dWF0aW9uRGVsaW1pdGVy",
            "EAISFgoSUHVuY3R1YXRpb25CcmFja2V0EAMSCwoHS2V5d29yZBAEEhkKEUlk",
            "ZW50aWZpZXJLZXl3b3JkEAQaAggBEhYKEklkZW50aWZpZXJPcGVyYXRvchAF",
            "Eg4KCklkZW50aWZpZXIQBhIVChFJZGVudGlmaWVyQnVpbHRpbhAHEhIKDklk",
            "ZW50aWZpZXJOdWxsEAgSFgoSSWRlbnRpZmllckNvbnN0YW50EAkSGwoXSWRl",
            "bnRpZmllck11dGFibGVHbG9iYWwQChIXChNJZGVudGlmaWVyUGFyYW1ldGVy",
            "EAsSEwoPSWRlbnRpZmllckxvY2FsEAwSFgoSSWRlbnRpZmllclNoYWRvd2Vk",
            "EA0SFwoTSWRlbnRpZmllck5hbWVzcGFjZRAOEhgKEElkZW50aWZpZXJNb2R1",
            "bGUQDhoCCAESFgoSSWRlbnRpZmllckZ1bmN0aW9uEA8SIAocSWRlbnRpZmll",
            "ckZ1bmN0aW9uRGVmaW5pdGlvbhAQEhMKD0lkZW50aWZpZXJNYWNybxAREh0K",
            "GUlkZW50aWZpZXJNYWNyb0RlZmluaXRpb24QEhISCg5JZGVudGlmaWVyVHlw",
            "ZRATEhkKFUlkZW50aWZpZXJCdWlsdGluVHlwZRAUEhcKE0lkZW50aWZpZXJB",
            "dHRyaWJ1dGUQFRIPCgtSZWdleEVzY2FwZRAWEhEKDVJlZ2V4UmVwZWF0ZWQQ",
            "FxIRCg1SZWdleFdpbGRjYXJkEBgSEgoOUmVnZXhEZWxpbWl0ZXIQGRINCglS",
            "ZWdleEpvaW4QGhIRCg1TdHJpbmdMaXRlcmFsEBsSFwoTU3RyaW5nTGl0ZXJh",
            "bEVzY2FwZRAcEhgKFFN0cmluZ0xpdGVyYWxTcGVjaWFsEB0SFAoQU3RyaW5n",
            "TGl0ZXJhbEtleRAeEhQKEENoYXJhY3RlckxpdGVyYWwQHxISCg5OdW1lcmlj",
            "TGl0ZXJhbBAgEhIKDkJvb2xlYW5MaXRlcmFsECESBwoDVGFnECISEAoMVGFn",
            "QXR0cmlidXRlECMSEAoMVGFnRGVsaW1pdGVyECQaAhABKlYKCFNldmVyaXR5",
            "EhcKE1Vuc3BlY2lmaWVkU2V2ZXJpdHkQABIJCgVFcnJvchABEgsKB1dhcm5p",
            "bmcQAhIPCgtJbmZvcm1hdGlvbhADEggKBEhpbnQQBCpOCg1EaWFnbm9zdGlj",
            "VGFnEhwKGFVuc3BlY2lmaWVkRGlhZ25vc3RpY1RhZxAAEg8KC1VubmVjZXNz",
            "YXJ5EAESDgoKRGVwcmVjYXRlZBACKpsKCghMYW5ndWFnZRIXChNVbnNwZWNp",
            "ZmllZExhbmd1YWdlEAASCAoEQUJBUBA8EggKBEFwZXgQYBIHCgNBUEwQMRIH",
            "CgNBZGEQJxIICgRBZ2RhEC0SDAoIQXNjaWlEb2MQVhIMCghBc3NlbWJseRA6",
            "EgcKA0F3axBCEgcKA0JhdBBEEgoKBkJpYlRlWBBREgUKAUMQIhIJCgVDT0JP",
            "TBA7EgcKA0NQUBAjEgcKA0NTUxAaEgoKBkNTaGFycBABEgsKB0Nsb2p1cmUQ",
            "CBIQCgxDb2ZmZWVzY3JpcHQQFRIOCgpDb21tb25MaXNwEAkSBwoDQ29xEC8S",
            "CAoEQ1VEQRBhEggKBERhcnQQAxIKCgZEZWxwaGkQORIICgREaWZmEFgSDgoK",
            "RG9ja2VyZmlsZRBQEgoKBkR5YWxvZxAyEgoKBkVsaXhpchAREgoKBkVybGFu",
            "ZxASEgoKBkZTaGFycBAqEggKBEZpc2gQQRIICgRGbG93EBgSCwoHRm9ydHJh",
            "bhA4Eg4KCkdpdF9Db21taXQQWxIOCgpHaXRfQ29uZmlnEFkSDgoKR2l0X1Jl",
            "YmFzZRBcEgYKAkdvECESCwoHR3JhcGhRTBBiEgoKBkdyb292eRAHEggKBEhU",
            "TUwQHhIICgRIYWNrEBQSDgoKSGFuZGxlYmFycxBaEgsKB0hhc2tlbGwQLBIJ",
            "CgVJZHJpcxAuEgcKA0luaRBIEgUKAUoQMxIICgRKU09OEEsSCAoESmF2YRAG",
            "Eg4KCkphdmFTY3JpcHQQFhITCg9KYXZhU2NyaXB0UmVhY3QQXRILCgdKc29u",
            "bmV0EEwSCQoFSnVsaWEQNxIMCghKdXN0ZmlsZRBtEgoKBktvdGxpbhAEEgkK",
            "BUxhVGVYEFMSCAoETGVhbhAwEggKBExlc3MQGxIHCgNMdWEQDBIICgRMdWF1",
            "EGwSDAoITWFrZWZpbGUQTxIMCghNYXJrZG93bhBUEgoKBk1hdGxhYhA0EgoK",
            "Bk5pY2tlbBBuEgcKA05peBBNEgkKBU9DYW1sECkSDwoLT2JqZWN0aXZlX0MQ",
            "JBIRCg1PYmplY3RpdmVfQ1BQECUSCgoGUGFzY2FsEGMSBwoDUEhQEBMSCQoF",
            "UExTUUwQRhIICgRQZXJsEA0SDgoKUG93ZXJTaGVsbBBDEgoKBlByb2xvZxBH",
            "EgwKCFByb3RvYnVmEGQSCgoGUHl0aG9uEA8SBQoBUhA2EgoKBlJhY2tldBAL",
            "EggKBFJha3UQDhIJCgVSYXpvchA+EgkKBVJlcHJvEGYSCAoEUmVTVBBVEggK",
            "BFJ1YnkQEBIICgRSdXN0ECgSBwoDU0FTED0SCAoEU0NTUxAdEgcKA1NNTBAr",
            "EgcKA1NRTBBFEggKBFNhc3MQHBIJCgVTY2FsYRAFEgoKBlNjaGVtZRAKEg8K",
            "C1NoZWxsU2NyaXB0EEASCwoHU2t5bGFyaxBOEgkKBVNsYW5nEGsSDAoIU29s",
            "aWRpdHkQXxIKCgZTdmVsdGUQahIJCgVTd2lmdBACEgcKA1RjbBBlEggKBFRP",
            "TUwQSRIHCgNUZVgQUhIKCgZUaHJpZnQQZxIOCgpUeXBlU2NyaXB0EBcSEwoP",
            "VHlwZVNjcmlwdFJlYWN0EF4SCwoHVmVyaWxvZxBoEggKBFZIREwQaRIPCgtW",
            "aXN1YWxCYXNpYxA/EgcKA1Z1ZRAZEgsKB1dvbGZyYW0QNRIHCgNYTUwQHxIH",
            "CgNYU0wQIBIICgRZQU1MEEoSBwoDWmlnECZCL1otZ2l0aHViLmNvbS9zb3Vy",
            "Y2VncmFwaC9zY2lwL2JpbmRpbmdzL2dvL3NjaXAvYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Scip.ProtocolVersion), typeof(global::Scip.TextEncoding), typeof(global::Scip.PositionEncoding), typeof(global::Scip.SymbolRole), typeof(global::Scip.SyntaxKind), typeof(global::Scip.Severity), typeof(global::Scip.DiagnosticTag), typeof(global::Scip.Language), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Scip.Index), global::Scip.Index.Parser, new[]{ "Metadata", "Documents", "ExternalSymbols" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scip.Metadata), global::Scip.Metadata.Parser, new[]{ "Version", "ToolInfo", "ProjectRoot", "TextDocumentEncoding" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scip.ToolInfo), global::Scip.ToolInfo.Parser, new[]{ "Name", "Version", "Arguments" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scip.Document), global::Scip.Document.Parser, new[]{ "Language", "RelativePath", "Occurrences", "Symbols", "Text", "PositionEncoding" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scip.Symbol), global::Scip.Symbol.Parser, new[]{ "Scheme", "Package", "Descriptors" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scip.Package), global::Scip.Package.Parser, new[]{ "Manager", "Name", "Version" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scip.SymbolDescriptor), global::Scip.SymbolDescriptor.Parser, new[]{ "Name", "Disambiguator", "Suffix" }, null, new[]{ typeof(global::Scip.SymbolDescriptor.Types.Suffix) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scip.SymbolInformation), global::Scip.SymbolInformation.Parser, new[]{ "Symbol", "Documentation", "Relationships", "Kind", "DisplayName", "SignatureDocumentation", "EnclosingSymbol" }, null, new[]{ typeof(global::Scip.SymbolInformation.Types.Kind) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scip.Relationship), global::Scip.Relationship.Parser, new[]{ "Symbol", "IsReference", "IsImplementation", "IsTypeDefinition", "IsDefinition" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scip.Occurrence), global::Scip.Occurrence.Parser, new[]{ "Range", "Symbol", "SymbolRoles", "OverrideDocumentation", "SyntaxKind", "Diagnostics", "EnclosingRange" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scip.Diagnostic), global::Scip.Diagnostic.Parser, new[]{ "Severity", "Code", "Message", "Source", "Tags" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  public enum ProtocolVersion {
    [pbr::OriginalName("UnspecifiedProtocolVersion")] UnspecifiedProtocolVersion = 0,
  }

  public enum TextEncoding {
    [pbr::OriginalName("UnspecifiedTextEncoding")] UnspecifiedTextEncoding = 0,
    [pbr::OriginalName("UTF8")] Utf8 = 1,
    [pbr::OriginalName("UTF16")] Utf16 = 2,
  }

  /// <summary>
  /// Encoding used to interpret the 'character' value in source ranges.
  /// </summary>
  public enum PositionEncoding {
    /// <summary>
    /// Default value. This value should not be used by new SCIP indexers
    /// so that a consumer can process the SCIP index without ambiguity.
    /// </summary>
    [pbr::OriginalName("UnspecifiedPositionEncoding")] UnspecifiedPositionEncoding = 0,
    /// <summary>
    /// The 'character' value is interpreted as an offset in terms
    /// of UTF-8 code units (i.e. bytes).
    ///
    /// Example: For the string "ðŸš€ Woo" in UTF-8, the bytes are
    /// [240, 159, 154, 128, 32, 87, 111, 111], so the offset for 'W'
    /// would be 5.
    /// </summary>
    [pbr::OriginalName("UTF8CodeUnitOffsetFromLineStart")] Utf8CodeUnitOffsetFromLineStart = 1,
    /// <summary>
    /// The 'character' value is interpreted as an offset in terms
    /// of UTF-16 code units (each is 2 bytes).
    ///
    /// Example: For the string "ðŸš€ Woo", the UTF-16 code units are
    /// ['\ud83d', '\ude80', ' ', 'W', 'o', 'o'], so the offset for 'W'
    /// would be 3.
    /// </summary>
    [pbr::OriginalName("UTF16CodeUnitOffsetFromLineStart")] Utf16CodeUnitOffsetFromLineStart = 2,
    /// <summary>
    /// The 'character' value is interpreted as an offset in terms
    /// of UTF-32 code units (each is 4 bytes).
    ///
    /// Example: For the string "ðŸš€ Woo", the UTF-32 code units are
    /// ['ðŸš€', ' ', 'W', 'o', 'o'], so the offset for 'W' would be 2.
    /// </summary>
    [pbr::OriginalName("UTF32CodeUnitOffsetFromLineStart")] Utf32CodeUnitOffsetFromLineStart = 3,
  }

  /// <summary>
  /// SymbolRole declares what "role" a symbol has in an occurrence. A role is
  /// encoded as a bitset where each bit represents a different role. For example,
  /// to determine if the `Import` role is set, test whether the second bit of the
  /// enum value is defined. In pseudocode, this can be implemented with the
  /// logic: `const isImportRole = (role.value &amp; SymbolRole.Import.value) > 0`.
  /// </summary>
  public enum SymbolRole {
    /// <summary>
    /// This case is not meant to be used; it only exists to avoid an error
    /// from the Protobuf code generator.
    /// </summary>
    [pbr::OriginalName("UnspecifiedSymbolRole")] UnspecifiedSymbolRole = 0,
    /// <summary>
    /// Is the symbol defined here? If not, then this is a symbol reference.
    /// </summary>
    [pbr::OriginalName("Definition")] Definition = 1,
    /// <summary>
    /// Is the symbol imported here?
    /// </summary>
    [pbr::OriginalName("Import")] Import = 2,
    /// <summary>
    /// Is the symbol written here?
    /// </summary>
    [pbr::OriginalName("WriteAccess")] WriteAccess = 4,
    /// <summary>
    /// Is the symbol read here?
    /// </summary>
    [pbr::OriginalName("ReadAccess")] ReadAccess = 8,
    /// <summary>
    /// Is the symbol in generated code?
    /// </summary>
    [pbr::OriginalName("Generated")] Generated = 16,
    /// <summary>
    /// Is the symbol in test code?
    /// </summary>
    [pbr::OriginalName("Test")] Test = 32,
    /// <summary>
    /// Is this a signature for a symbol that is defined elsewhere?
    ///
    /// Applies to forward declarations for languages like C, C++
    /// and Objective-C, as well as `val` declarations in interface
    /// files in languages like SML and OCaml.
    /// </summary>
    [pbr::OriginalName("ForwardDefinition")] ForwardDefinition = 64,
  }

  public enum SyntaxKind {
    [pbr::OriginalName("UnspecifiedSyntaxKind")] UnspecifiedSyntaxKind = 0,
    /// <summary>
    /// Comment, including comment markers and text
    /// </summary>
    [pbr::OriginalName("Comment")] Comment = 1,
    /// <summary>
    /// `;` `.` `,`
    /// </summary>
    [pbr::OriginalName("PunctuationDelimiter")] PunctuationDelimiter = 2,
    /// <summary>
    /// (), {}, [] when used syntactically
    /// </summary>
    [pbr::OriginalName("PunctuationBracket")] PunctuationBracket = 3,
    /// <summary>
    /// `if`, `else`, `return`, `class`, etc.
    /// </summary>
    [pbr::OriginalName("Keyword")] Keyword = 4,
    [global::System.ObsoleteAttribute]
    [pbr::OriginalName("IdentifierKeyword", PreferredAlias = false)] IdentifierKeyword = 4,
    /// <summary>
    /// `+`, `*`, etc.
    /// </summary>
    [pbr::OriginalName("IdentifierOperator")] IdentifierOperator = 5,
    /// <summary>
    /// non-specific catch-all for any identifier not better described elsewhere
    /// </summary>
    [pbr::OriginalName("Identifier")] Identifier = 6,
    /// <summary>
    /// Identifiers builtin to the language: `min`, `print` in Python.
    /// </summary>
    [pbr::OriginalName("IdentifierBuiltin")] IdentifierBuiltin = 7,
    /// <summary>
    /// Identifiers representing `null`-like values: `None` in Python, `nil` in Go.
    /// </summary>
    [pbr::OriginalName("IdentifierNull")] IdentifierNull = 8,
    /// <summary>
    /// `xyz` in `const xyz = "hello"`
    /// </summary>
    [pbr::OriginalName("IdentifierConstant")] IdentifierConstant = 9,
    /// <summary>
    /// `var X = "hello"` in Go
    /// </summary>
    [pbr::OriginalName("IdentifierMutableGlobal")] IdentifierMutableGlobal = 10,
    /// <summary>
    /// Parameter definition and references
    /// </summary>
    [pbr::OriginalName("IdentifierParameter")] IdentifierParameter = 11,
    /// <summary>
    /// Identifiers for variable definitions and references within a local scope
    /// </summary>
    [pbr::OriginalName("IdentifierLocal")] IdentifierLocal = 12,
    /// <summary>
    /// Identifiers that shadow other identifiers in an outer scope
    /// </summary>
    [pbr::OriginalName("IdentifierShadowed")] IdentifierShadowed = 13,
    /// <summary>
    /// Identifier representing a unit of code abstraction and/or namespacing.
    ///
    /// NOTE: This corresponds to a package in Go and JVM languages,
    /// and a module in languages like Python and JavaScript.
    /// </summary>
    [pbr::OriginalName("IdentifierNamespace")] IdentifierNamespace = 14,
    [global::System.ObsoleteAttribute]
    [pbr::OriginalName("IdentifierModule", PreferredAlias = false)] IdentifierModule = 14,
    /// <summary>
    /// Function references, including calls
    /// </summary>
    [pbr::OriginalName("IdentifierFunction")] IdentifierFunction = 15,
    /// <summary>
    /// Function definition only
    /// </summary>
    [pbr::OriginalName("IdentifierFunctionDefinition")] IdentifierFunctionDefinition = 16,
    /// <summary>
    /// Macro references, including invocations
    /// </summary>
    [pbr::OriginalName("IdentifierMacro")] IdentifierMacro = 17,
    /// <summary>
    /// Macro definition only
    /// </summary>
    [pbr::OriginalName("IdentifierMacroDefinition")] IdentifierMacroDefinition = 18,
    /// <summary>
    /// non-builtin types
    /// </summary>
    [pbr::OriginalName("IdentifierType")] IdentifierType = 19,
    /// <summary>
    /// builtin types only, such as `str` for Python or `int` in Go
    /// </summary>
    [pbr::OriginalName("IdentifierBuiltinType")] IdentifierBuiltinType = 20,
    /// <summary>
    /// Python decorators, c-like __attribute__
    /// </summary>
    [pbr::OriginalName("IdentifierAttribute")] IdentifierAttribute = 21,
    /// <summary>
    /// `\b`
    /// </summary>
    [pbr::OriginalName("RegexEscape")] RegexEscape = 22,
    /// <summary>
    /// `*`, `+`
    /// </summary>
    [pbr::OriginalName("RegexRepeated")] RegexRepeated = 23,
    /// <summary>
    /// `.`
    /// </summary>
    [pbr::OriginalName("RegexWildcard")] RegexWildcard = 24,
    /// <summary>
    /// `(`, `)`, `[`, `]`
    /// </summary>
    [pbr::OriginalName("RegexDelimiter")] RegexDelimiter = 25,
    /// <summary>
    /// `|`, `-`
    /// </summary>
    [pbr::OriginalName("RegexJoin")] RegexJoin = 26,
    /// <summary>
    /// Literal strings: "Hello, world!"
    /// </summary>
    [pbr::OriginalName("StringLiteral")] StringLiteral = 27,
    /// <summary>
    /// non-regex escapes: "\t", "\n"
    /// </summary>
    [pbr::OriginalName("StringLiteralEscape")] StringLiteralEscape = 28,
    /// <summary>
    /// datetimes within strings, special words within a string, `{}` in format strings
    /// </summary>
    [pbr::OriginalName("StringLiteralSpecial")] StringLiteralSpecial = 29,
    /// <summary>
    /// "key" in { "key": "value" }, useful for example in JSON
    /// </summary>
    [pbr::OriginalName("StringLiteralKey")] StringLiteralKey = 30,
    /// <summary>
    /// 'c' or similar, in languages that differentiate strings and characters
    /// </summary>
    [pbr::OriginalName("CharacterLiteral")] CharacterLiteral = 31,
    /// <summary>
    /// Literal numbers, both floats and integers
    /// </summary>
    [pbr::OriginalName("NumericLiteral")] NumericLiteral = 32,
    /// <summary>
    /// `true`, `false`
    /// </summary>
    [pbr::OriginalName("BooleanLiteral")] BooleanLiteral = 33,
    /// <summary>
    /// Used for XML-like tags
    /// </summary>
    [pbr::OriginalName("Tag")] Tag = 34,
    /// <summary>
    /// Attribute name in XML-like tags
    /// </summary>
    [pbr::OriginalName("TagAttribute")] TagAttribute = 35,
    /// <summary>
    /// Delimiters for XML-like tags
    /// </summary>
    [pbr::OriginalName("TagDelimiter")] TagDelimiter = 36,
  }

  public enum Severity {
    [pbr::OriginalName("UnspecifiedSeverity")] UnspecifiedSeverity = 0,
    [pbr::OriginalName("Error")] Error = 1,
    [pbr::OriginalName("Warning")] Warning = 2,
    [pbr::OriginalName("Information")] Information = 3,
    [pbr::OriginalName("Hint")] Hint = 4,
  }

  public enum DiagnosticTag {
    [pbr::OriginalName("UnspecifiedDiagnosticTag")] UnspecifiedDiagnosticTag = 0,
    [pbr::OriginalName("Unnecessary")] Unnecessary = 1,
    [pbr::OriginalName("Deprecated")] Deprecated = 2,
  }

  /// <summary>
  /// Language standardises names of common programming languages that can be used
  /// for the `Document.language` field. The primary purpose of this enum is to
  /// prevent a situation where we have a single programming language ends up with
  /// multiple string representations. For example, the C++ language uses the name
  /// "CPP" in this enum and other names such as "cpp" are incompatible.
  /// Feel free to send a pull-request to add missing programming languages.
  /// </summary>
  public enum Language {
    [pbr::OriginalName("UnspecifiedLanguage")] UnspecifiedLanguage = 0,
    [pbr::OriginalName("ABAP")] Abap = 60,
    [pbr::OriginalName("Apex")] Apex = 96,
    [pbr::OriginalName("APL")] Apl = 49,
    [pbr::OriginalName("Ada")] Ada = 39,
    [pbr::OriginalName("Agda")] Agda = 45,
    [pbr::OriginalName("AsciiDoc")] AsciiDoc = 86,
    [pbr::OriginalName("Assembly")] Assembly = 58,
    [pbr::OriginalName("Awk")] Awk = 66,
    [pbr::OriginalName("Bat")] Bat = 68,
    [pbr::OriginalName("BibTeX")] BibTeX = 81,
    [pbr::OriginalName("C")] C = 34,
    [pbr::OriginalName("COBOL")] Cobol = 59,
    /// <summary>
    /// C++ (the name "CPP" was chosen for consistency with LSP)
    /// </summary>
    [pbr::OriginalName("CPP")] Cpp = 35,
    [pbr::OriginalName("CSS")] Css = 26,
    [pbr::OriginalName("CSharp")] Csharp = 1,
    [pbr::OriginalName("Clojure")] Clojure = 8,
    [pbr::OriginalName("Coffeescript")] Coffeescript = 21,
    [pbr::OriginalName("CommonLisp")] CommonLisp = 9,
    [pbr::OriginalName("Coq")] Coq = 47,
    [pbr::OriginalName("CUDA")] Cuda = 97,
    [pbr::OriginalName("Dart")] Dart = 3,
    [pbr::OriginalName("Delphi")] Delphi = 57,
    [pbr::OriginalName("Diff")] Diff = 88,
    [pbr::OriginalName("Dockerfile")] Dockerfile = 80,
    [pbr::OriginalName("Dyalog")] Dyalog = 50,
    [pbr::OriginalName("Elixir")] Elixir = 17,
    [pbr::OriginalName("Erlang")] Erlang = 18,
    [pbr::OriginalName("FSharp")] Fsharp = 42,
    [pbr::OriginalName("Fish")] Fish = 65,
    [pbr::OriginalName("Flow")] Flow = 24,
    [pbr::OriginalName("Fortran")] Fortran = 56,
    [pbr::OriginalName("Git_Commit")] GitCommit = 91,
    [pbr::OriginalName("Git_Config")] GitConfig = 89,
    [pbr::OriginalName("Git_Rebase")] GitRebase = 92,
    [pbr::OriginalName("Go")] Go = 33,
    [pbr::OriginalName("GraphQL")] GraphQl = 98,
    [pbr::OriginalName("Groovy")] Groovy = 7,
    [pbr::OriginalName("HTML")] Html = 30,
    [pbr::OriginalName("Hack")] Hack = 20,
    [pbr::OriginalName("Handlebars")] Handlebars = 90,
    [pbr::OriginalName("Haskell")] Haskell = 44,
    [pbr::OriginalName("Idris")] Idris = 46,
    [pbr::OriginalName("Ini")] Ini = 72,
    [pbr::OriginalName("J")] J = 51,
    [pbr::OriginalName("JSON")] Json = 75,
    [pbr::OriginalName("Java")] Java = 6,
    [pbr::OriginalName("JavaScript")] JavaScript = 22,
    [pbr::OriginalName("JavaScriptReact")] JavaScriptReact = 93,
    [pbr::OriginalName("Jsonnet")] Jsonnet = 76,
    [pbr::OriginalName("Julia")] Julia = 55,
    [pbr::OriginalName("Justfile")] Justfile = 109,
    [pbr::OriginalName("Kotlin")] Kotlin = 4,
    [pbr::OriginalName("LaTeX")] LaTeX = 83,
    [pbr::OriginalName("Lean")] Lean = 48,
    [pbr::OriginalName("Less")] Less = 27,
    [pbr::OriginalName("Lua")] Lua = 12,
    [pbr::OriginalName("Luau")] Luau = 108,
    [pbr::OriginalName("Makefile")] Makefile = 79,
    [pbr::OriginalName("Markdown")] Markdown = 84,
    [pbr::OriginalName("Matlab")] Matlab = 52,
    /// <summary>
    /// https://nickel-lang.org/
    /// </summary>
    [pbr::OriginalName("Nickel")] Nickel = 110,
    [pbr::OriginalName("Nix")] Nix = 77,
    [pbr::OriginalName("OCaml")] Ocaml = 41,
    [pbr::OriginalName("Objective_C")] ObjectiveC = 36,
    [pbr::OriginalName("Objective_CPP")] ObjectiveCpp = 37,
    [pbr::OriginalName("Pascal")] Pascal = 99,
    [pbr::OriginalName("PHP")] Php = 19,
    [pbr::OriginalName("PLSQL")] Plsql = 70,
    [pbr::OriginalName("Perl")] Perl = 13,
    [pbr::OriginalName("PowerShell")] PowerShell = 67,
    [pbr::OriginalName("Prolog")] Prolog = 71,
    [pbr::OriginalName("Protobuf")] Protobuf = 100,
    [pbr::OriginalName("Python")] Python = 15,
    [pbr::OriginalName("R")] R = 54,
    [pbr::OriginalName("Racket")] Racket = 11,
    [pbr::OriginalName("Raku")] Raku = 14,
    [pbr::OriginalName("Razor")] Razor = 62,
    /// <summary>
    /// Internal language for testing SCIP
    /// </summary>
    [pbr::OriginalName("Repro")] Repro = 102,
    [pbr::OriginalName("ReST")] ReSt = 85,
    [pbr::OriginalName("Ruby")] Ruby = 16,
    [pbr::OriginalName("Rust")] Rust = 40,
    [pbr::OriginalName("SAS")] Sas = 61,
    [pbr::OriginalName("SCSS")] Scss = 29,
    [pbr::OriginalName("SML")] Sml = 43,
    [pbr::OriginalName("SQL")] Sql = 69,
    [pbr::OriginalName("Sass")] Sass = 28,
    [pbr::OriginalName("Scala")] Scala = 5,
    [pbr::OriginalName("Scheme")] Scheme = 10,
    /// <summary>
    /// Bash
    /// </summary>
    [pbr::OriginalName("ShellScript")] ShellScript = 64,
    [pbr::OriginalName("Skylark")] Skylark = 78,
    [pbr::OriginalName("Slang")] Slang = 107,
    [pbr::OriginalName("Solidity")] Solidity = 95,
    [pbr::OriginalName("Svelte")] Svelte = 106,
    [pbr::OriginalName("Swift")] Swift = 2,
    [pbr::OriginalName("Tcl")] Tcl = 101,
    [pbr::OriginalName("TOML")] Toml = 73,
    [pbr::OriginalName("TeX")] TeX = 82,
    [pbr::OriginalName("Thrift")] Thrift = 103,
    [pbr::OriginalName("TypeScript")] TypeScript = 23,
    [pbr::OriginalName("TypeScriptReact")] TypeScriptReact = 94,
    [pbr::OriginalName("Verilog")] Verilog = 104,
    [pbr::OriginalName("VHDL")] Vhdl = 105,
    [pbr::OriginalName("VisualBasic")] VisualBasic = 63,
    [pbr::OriginalName("Vue")] Vue = 25,
    [pbr::OriginalName("Wolfram")] Wolfram = 53,
    [pbr::OriginalName("XML")] Xml = 31,
    [pbr::OriginalName("XSL")] Xsl = 32,
    [pbr::OriginalName("YAML")] Yaml = 74,
    /// <summary>
    /// NextLanguage = 111;
    /// Steps add a new language:
    /// 1. Copy-paste the "NextLanguage = N" line above
    /// 2. Increment "NextLanguage = N" to "NextLanguage = N+1"
    /// 3. Replace "NextLanguage = N" with the name of the new language.
    /// 4. Move the new language to the correct line above using alphabetical order
    /// 5. (optional) Add a brief comment behind the language if the name is not self-explanatory
    /// </summary>
    [pbr::OriginalName("Zig")] Zig = 38,
  }

  #endregion

  #region Messages
  /// <summary>
  /// Index represents a complete SCIP index for a workspace this is rooted at a
  /// single directory. An Index message payload can have a large memory footprint
  /// and it's therefore recommended to emit and consume an Index payload one field
  /// value at a time. To permit streaming consumption of an Index payload, the
  /// `metadata` field must appear at the start of the stream and must only appear
  /// once in the stream. Other field values may appear in any order.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Index : pb::IMessage<Index>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Index> _parser = new pb::MessageParser<Index>(() => new Index());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Index> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scip.ScipReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Index() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Index(Index other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      documents_ = other.documents_.Clone();
      externalSymbols_ = other.externalSymbols_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Index Clone() {
      return new Index(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::Scip.Metadata metadata_;
    /// <summary>
    /// Metadata about this index.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Scip.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "documents" field.</summary>
    public const int DocumentsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Scip.Document> _repeated_documents_codec
        = pb::FieldCodec.ForMessage(18, global::Scip.Document.Parser);
    private readonly pbc::RepeatedField<global::Scip.Document> documents_ = new pbc::RepeatedField<global::Scip.Document>();
    /// <summary>
    /// Documents that belong to this index.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Scip.Document> Documents {
      get { return documents_; }
    }

    /// <summary>Field number for the "external_symbols" field.</summary>
    public const int ExternalSymbolsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Scip.SymbolInformation> _repeated_externalSymbols_codec
        = pb::FieldCodec.ForMessage(26, global::Scip.SymbolInformation.Parser);
    private readonly pbc::RepeatedField<global::Scip.SymbolInformation> externalSymbols_ = new pbc::RepeatedField<global::Scip.SymbolInformation>();
    /// <summary>
    /// (optional) Symbols that are referenced from this index but are defined in
    /// an external package (a separate `Index` message). Leave this field empty
    /// if you assume the external package will get indexed separately. If the
    /// external package won't get indexed for some reason then you can use this
    /// field to provide hover documentation for those external symbols.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Scip.SymbolInformation> ExternalSymbols {
      get { return externalSymbols_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Index);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Index other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!documents_.Equals(other.documents_)) return false;
      if(!externalSymbols_.Equals(other.externalSymbols_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= documents_.GetHashCode();
      hash ^= externalSymbols_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      documents_.WriteTo(output, _repeated_documents_codec);
      externalSymbols_.WriteTo(output, _repeated_externalSymbols_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      documents_.WriteTo(ref output, _repeated_documents_codec);
      externalSymbols_.WriteTo(ref output, _repeated_externalSymbols_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += documents_.CalculateSize(_repeated_documents_codec);
      size += externalSymbols_.CalculateSize(_repeated_externalSymbols_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Index other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::Scip.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      documents_.Add(other.documents_);
      externalSymbols_.Add(other.externalSymbols_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::Scip.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            documents_.AddEntriesFrom(input, _repeated_documents_codec);
            break;
          }
          case 26: {
            externalSymbols_.AddEntriesFrom(input, _repeated_externalSymbols_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::Scip.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            documents_.AddEntriesFrom(ref input, _repeated_documents_codec);
            break;
          }
          case 26: {
            externalSymbols_.AddEntriesFrom(ref input, _repeated_externalSymbols_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Metadata : pb::IMessage<Metadata>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Metadata> _parser = new pb::MessageParser<Metadata>(() => new Metadata());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Metadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scip.ScipReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Metadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Metadata(Metadata other) : this() {
      version_ = other.version_;
      toolInfo_ = other.toolInfo_ != null ? other.toolInfo_.Clone() : null;
      projectRoot_ = other.projectRoot_;
      textDocumentEncoding_ = other.textDocumentEncoding_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Metadata Clone() {
      return new Metadata(this);
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 1;
    private global::Scip.ProtocolVersion version_ = global::Scip.ProtocolVersion.UnspecifiedProtocolVersion;
    /// <summary>
    /// Which version of this protocol was used to generate this index?
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Scip.ProtocolVersion Version {
      get { return version_; }
      set {
        version_ = value;
      }
    }

    /// <summary>Field number for the "tool_info" field.</summary>
    public const int ToolInfoFieldNumber = 2;
    private global::Scip.ToolInfo toolInfo_;
    /// <summary>
    /// Information about the tool that produced this index.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Scip.ToolInfo ToolInfo {
      get { return toolInfo_; }
      set {
        toolInfo_ = value;
      }
    }

    /// <summary>Field number for the "project_root" field.</summary>
    public const int ProjectRootFieldNumber = 3;
    private string projectRoot_ = "";
    /// <summary>
    /// URI-encoded absolute path to the root directory of this index. All
    /// documents in this index must appear in a subdirectory of this root
    /// directory.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ProjectRoot {
      get { return projectRoot_; }
      set {
        projectRoot_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "text_document_encoding" field.</summary>
    public const int TextDocumentEncodingFieldNumber = 4;
    private global::Scip.TextEncoding textDocumentEncoding_ = global::Scip.TextEncoding.UnspecifiedTextEncoding;
    /// <summary>
    /// Text encoding of the source files on disk that are referenced from
    /// `Document.relative_path`. This value is unrelated to the `Document.text`
    /// field, which is a Protobuf string and hence must be UTF-8 encoded.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Scip.TextEncoding TextDocumentEncoding {
      get { return textDocumentEncoding_; }
      set {
        textDocumentEncoding_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Metadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Metadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Version != other.Version) return false;
      if (!object.Equals(ToolInfo, other.ToolInfo)) return false;
      if (ProjectRoot != other.ProjectRoot) return false;
      if (TextDocumentEncoding != other.TextDocumentEncoding) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Version != global::Scip.ProtocolVersion.UnspecifiedProtocolVersion) hash ^= Version.GetHashCode();
      if (toolInfo_ != null) hash ^= ToolInfo.GetHashCode();
      if (ProjectRoot.Length != 0) hash ^= ProjectRoot.GetHashCode();
      if (TextDocumentEncoding != global::Scip.TextEncoding.UnspecifiedTextEncoding) hash ^= TextDocumentEncoding.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Version != global::Scip.ProtocolVersion.UnspecifiedProtocolVersion) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Version);
      }
      if (toolInfo_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ToolInfo);
      }
      if (ProjectRoot.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(ProjectRoot);
      }
      if (TextDocumentEncoding != global::Scip.TextEncoding.UnspecifiedTextEncoding) {
        output.WriteRawTag(32);
        output.WriteEnum((int) TextDocumentEncoding);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Version != global::Scip.ProtocolVersion.UnspecifiedProtocolVersion) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Version);
      }
      if (toolInfo_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ToolInfo);
      }
      if (ProjectRoot.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(ProjectRoot);
      }
      if (TextDocumentEncoding != global::Scip.TextEncoding.UnspecifiedTextEncoding) {
        output.WriteRawTag(32);
        output.WriteEnum((int) TextDocumentEncoding);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Version != global::Scip.ProtocolVersion.UnspecifiedProtocolVersion) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Version);
      }
      if (toolInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ToolInfo);
      }
      if (ProjectRoot.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProjectRoot);
      }
      if (TextDocumentEncoding != global::Scip.TextEncoding.UnspecifiedTextEncoding) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TextDocumentEncoding);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Metadata other) {
      if (other == null) {
        return;
      }
      if (other.Version != global::Scip.ProtocolVersion.UnspecifiedProtocolVersion) {
        Version = other.Version;
      }
      if (other.toolInfo_ != null) {
        if (toolInfo_ == null) {
          ToolInfo = new global::Scip.ToolInfo();
        }
        ToolInfo.MergeFrom(other.ToolInfo);
      }
      if (other.ProjectRoot.Length != 0) {
        ProjectRoot = other.ProjectRoot;
      }
      if (other.TextDocumentEncoding != global::Scip.TextEncoding.UnspecifiedTextEncoding) {
        TextDocumentEncoding = other.TextDocumentEncoding;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Version = (global::Scip.ProtocolVersion) input.ReadEnum();
            break;
          }
          case 18: {
            if (toolInfo_ == null) {
              ToolInfo = new global::Scip.ToolInfo();
            }
            input.ReadMessage(ToolInfo);
            break;
          }
          case 26: {
            ProjectRoot = input.ReadString();
            break;
          }
          case 32: {
            TextDocumentEncoding = (global::Scip.TextEncoding) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Version = (global::Scip.ProtocolVersion) input.ReadEnum();
            break;
          }
          case 18: {
            if (toolInfo_ == null) {
              ToolInfo = new global::Scip.ToolInfo();
            }
            input.ReadMessage(ToolInfo);
            break;
          }
          case 26: {
            ProjectRoot = input.ReadString();
            break;
          }
          case 32: {
            TextDocumentEncoding = (global::Scip.TextEncoding) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ToolInfo : pb::IMessage<ToolInfo>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ToolInfo> _parser = new pb::MessageParser<ToolInfo>(() => new ToolInfo());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ToolInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scip.ScipReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ToolInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ToolInfo(ToolInfo other) : this() {
      name_ = other.name_;
      version_ = other.version_;
      arguments_ = other.arguments_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ToolInfo Clone() {
      return new ToolInfo(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Name of the indexer that produced this index.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 2;
    private string version_ = "";
    /// <summary>
    /// Version of the indexer that produced this index.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Version {
      get { return version_; }
      set {
        version_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "arguments" field.</summary>
    public const int ArgumentsFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_arguments_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> arguments_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Command-line arguments that were used to invoke this indexer.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Arguments {
      get { return arguments_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ToolInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ToolInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Version != other.Version) return false;
      if(!arguments_.Equals(other.arguments_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Version.Length != 0) hash ^= Version.GetHashCode();
      hash ^= arguments_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Version.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Version);
      }
      arguments_.WriteTo(output, _repeated_arguments_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Version.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Version);
      }
      arguments_.WriteTo(ref output, _repeated_arguments_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Version.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Version);
      }
      size += arguments_.CalculateSize(_repeated_arguments_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ToolInfo other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Version.Length != 0) {
        Version = other.Version;
      }
      arguments_.Add(other.arguments_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Version = input.ReadString();
            break;
          }
          case 26: {
            arguments_.AddEntriesFrom(input, _repeated_arguments_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Version = input.ReadString();
            break;
          }
          case 26: {
            arguments_.AddEntriesFrom(ref input, _repeated_arguments_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Document defines the metadata about a source file on disk.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Document : pb::IMessage<Document>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Document> _parser = new pb::MessageParser<Document>(() => new Document());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Document> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scip.ScipReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Document() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Document(Document other) : this() {
      language_ = other.language_;
      relativePath_ = other.relativePath_;
      occurrences_ = other.occurrences_.Clone();
      symbols_ = other.symbols_.Clone();
      text_ = other.text_;
      positionEncoding_ = other.positionEncoding_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Document Clone() {
      return new Document(this);
    }

    /// <summary>Field number for the "language" field.</summary>
    public const int LanguageFieldNumber = 4;
    private string language_ = "";
    /// <summary>
    /// The string ID for the programming language this file is written in.
    /// The `Language` enum contains the names of most common programming languages.
    /// This field is typed as a string to permit any programming language, including
    /// ones that are not specified by the `Language` enum.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Language {
      get { return language_; }
      set {
        language_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "relative_path" field.</summary>
    public const int RelativePathFieldNumber = 1;
    private string relativePath_ = "";
    /// <summary>
    /// (Required) Unique path to the text document.
    ///
    /// 1. The path must be relative to the directory supplied in the associated
    ///    `Metadata.project_root`.
    /// 2. The path must not begin with a leading '/'.
    /// 3. The path must point to a regular file, not a symbolic link.
    /// 4. The path must use '/' as the separator, including on Windows.
    /// 5. The path must be canonical; it cannot include empty components ('//'),
    ///    or '.' or '..'.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RelativePath {
      get { return relativePath_; }
      set {
        relativePath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "occurrences" field.</summary>
    public const int OccurrencesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Scip.Occurrence> _repeated_occurrences_codec
        = pb::FieldCodec.ForMessage(18, global::Scip.Occurrence.Parser);
    private readonly pbc::RepeatedField<global::Scip.Occurrence> occurrences_ = new pbc::RepeatedField<global::Scip.Occurrence>();
    /// <summary>
    /// Occurrences that appear in this file.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Scip.Occurrence> Occurrences {
      get { return occurrences_; }
    }

    /// <summary>Field number for the "symbols" field.</summary>
    public const int SymbolsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Scip.SymbolInformation> _repeated_symbols_codec
        = pb::FieldCodec.ForMessage(26, global::Scip.SymbolInformation.Parser);
    private readonly pbc::RepeatedField<global::Scip.SymbolInformation> symbols_ = new pbc::RepeatedField<global::Scip.SymbolInformation>();
    /// <summary>
    /// Symbols that are "defined" within this document.
    ///
    /// This should include symbols which technically do not have any definition,
    /// but have a reference and are defined by some other symbol (see
    /// Relationship.is_definition).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Scip.SymbolInformation> Symbols {
      get { return symbols_; }
    }

    /// <summary>Field number for the "text" field.</summary>
    public const int TextFieldNumber = 5;
    private string text_ = "";
    /// <summary>
    /// (optional) Text contents of the this document. Indexers are not expected to
    /// include the text by default. It's preferrable that clients read the text
    /// contents from the file system by resolving the absolute path from joining
    /// `Index.metadata.project_root` and `Document.relative_path`. This field was
    /// introduced to support `SymbolInformation.signature_documentation`, but it
    /// can be used for other purposes as well, for example testing or when working
    /// with virtual/in-memory documents.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Text {
      get { return text_; }
      set {
        text_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "position_encoding" field.</summary>
    public const int PositionEncodingFieldNumber = 6;
    private global::Scip.PositionEncoding positionEncoding_ = global::Scip.PositionEncoding.UnspecifiedPositionEncoding;
    /// <summary>
    /// Specifies the encoding used for source ranges in this Document.
    ///
    /// Usually, this will match the type used to index the string type
    /// in the indexer's implementation language in O(1) time.
    /// - For an indexer implemented in JVM/.NET language or JavaScript/TypeScript,
    ///   use UTF16CodeUnitOffsetFromLineStart.
    /// - For an indexer implemented in Python,
    ///   use UTF32CodeUnitOffsetFromLineStart.
    /// - For an indexer implemented in Go, Rust or C++,
    ///   use UTF8ByteOffsetFromLineStart.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Scip.PositionEncoding PositionEncoding {
      get { return positionEncoding_; }
      set {
        positionEncoding_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Document);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Document other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Language != other.Language) return false;
      if (RelativePath != other.RelativePath) return false;
      if(!occurrences_.Equals(other.occurrences_)) return false;
      if(!symbols_.Equals(other.symbols_)) return false;
      if (Text != other.Text) return false;
      if (PositionEncoding != other.PositionEncoding) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Language.Length != 0) hash ^= Language.GetHashCode();
      if (RelativePath.Length != 0) hash ^= RelativePath.GetHashCode();
      hash ^= occurrences_.GetHashCode();
      hash ^= symbols_.GetHashCode();
      if (Text.Length != 0) hash ^= Text.GetHashCode();
      if (PositionEncoding != global::Scip.PositionEncoding.UnspecifiedPositionEncoding) hash ^= PositionEncoding.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (RelativePath.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(RelativePath);
      }
      occurrences_.WriteTo(output, _repeated_occurrences_codec);
      symbols_.WriteTo(output, _repeated_symbols_codec);
      if (Language.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Language);
      }
      if (Text.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Text);
      }
      if (PositionEncoding != global::Scip.PositionEncoding.UnspecifiedPositionEncoding) {
        output.WriteRawTag(48);
        output.WriteEnum((int) PositionEncoding);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (RelativePath.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(RelativePath);
      }
      occurrences_.WriteTo(ref output, _repeated_occurrences_codec);
      symbols_.WriteTo(ref output, _repeated_symbols_codec);
      if (Language.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Language);
      }
      if (Text.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Text);
      }
      if (PositionEncoding != global::Scip.PositionEncoding.UnspecifiedPositionEncoding) {
        output.WriteRawTag(48);
        output.WriteEnum((int) PositionEncoding);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Language.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Language);
      }
      if (RelativePath.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RelativePath);
      }
      size += occurrences_.CalculateSize(_repeated_occurrences_codec);
      size += symbols_.CalculateSize(_repeated_symbols_codec);
      if (Text.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Text);
      }
      if (PositionEncoding != global::Scip.PositionEncoding.UnspecifiedPositionEncoding) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) PositionEncoding);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Document other) {
      if (other == null) {
        return;
      }
      if (other.Language.Length != 0) {
        Language = other.Language;
      }
      if (other.RelativePath.Length != 0) {
        RelativePath = other.RelativePath;
      }
      occurrences_.Add(other.occurrences_);
      symbols_.Add(other.symbols_);
      if (other.Text.Length != 0) {
        Text = other.Text;
      }
      if (other.PositionEncoding != global::Scip.PositionEncoding.UnspecifiedPositionEncoding) {
        PositionEncoding = other.PositionEncoding;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            RelativePath = input.ReadString();
            break;
          }
          case 18: {
            occurrences_.AddEntriesFrom(input, _repeated_occurrences_codec);
            break;
          }
          case 26: {
            symbols_.AddEntriesFrom(input, _repeated_symbols_codec);
            break;
          }
          case 34: {
            Language = input.ReadString();
            break;
          }
          case 42: {
            Text = input.ReadString();
            break;
          }
          case 48: {
            PositionEncoding = (global::Scip.PositionEncoding) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            RelativePath = input.ReadString();
            break;
          }
          case 18: {
            occurrences_.AddEntriesFrom(ref input, _repeated_occurrences_codec);
            break;
          }
          case 26: {
            symbols_.AddEntriesFrom(ref input, _repeated_symbols_codec);
            break;
          }
          case 34: {
            Language = input.ReadString();
            break;
          }
          case 42: {
            Text = input.ReadString();
            break;
          }
          case 48: {
            PositionEncoding = (global::Scip.PositionEncoding) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Symbol is similar to a URI, it identifies a class, method, or a local
  /// variable. `SymbolInformation` contains rich metadata about symbols such as
  /// the docstring.
  ///
  /// Symbol has a standardized string representation, which can be used
  /// interchangeably with `Symbol`. The syntax for Symbol is the following:
  /// ```
  /// # (&lt;x>)+ stands for one or more repetitions of &lt;x>
  /// # (&lt;x>)? stands for zero or one occurrence of &lt;x>
  /// &lt;symbol>               ::= &lt;scheme> ' ' &lt;package> ' ' (&lt;descriptor>)+ | 'local ' &lt;local-id>
  /// &lt;package>              ::= &lt;manager> ' ' &lt;package-name> ' ' &lt;version>
  /// &lt;scheme>               ::= any UTF-8, escape spaces with double space. Must not be empty nor start with 'local'
  /// &lt;manager>              ::= any UTF-8, escape spaces with double space. Use the placeholder '.' to indicate an empty value
  /// &lt;package-name>         ::= same as above
  /// &lt;version>              ::= same as above
  /// &lt;descriptor>           ::= &lt;namespace> | &lt;type> | &lt;term> | &lt;method> | &lt;type-parameter> | &lt;parameter> | &lt;meta> | &lt;macro>
  /// &lt;namespace>            ::= &lt;name> '/'
  /// &lt;type>                 ::= &lt;name> '#'
  /// &lt;term>                 ::= &lt;name> '.'
  /// &lt;meta>                 ::= &lt;name> ':'
  /// &lt;macro>                ::= &lt;name> '!'
  /// &lt;method>               ::= &lt;name> '(' (&lt;method-disambiguator>)? ').'
  /// &lt;type-parameter>       ::= '[' &lt;name> ']'
  /// &lt;parameter>            ::= '(' &lt;name> ')'
  /// &lt;name>                 ::= &lt;identifier>
  /// &lt;method-disambiguator> ::= &lt;simple-identifier>
  /// &lt;identifier>           ::= &lt;simple-identifier> | &lt;escaped-identifier>
  /// &lt;simple-identifier>    ::= (&lt;identifier-character>)+
  /// &lt;identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit
  /// &lt;escaped-identifier>   ::= '`' (&lt;escaped-character>)+ '`', must contain at least one non-&lt;identifier-character>
  /// &lt;escaped-characters>   ::= any UTF-8, escape backticks with double backtick.
  /// &lt;local-id>             ::= &lt;simple-identifier>
  /// ```
  ///
  /// The list of descriptors for a symbol should together form a fully
  /// qualified name for the symbol. That is, it should serve as a unique
  /// identifier across the package. Typically, it will include one descriptor
  /// for every node in the AST (along the ancestry path) between the root of
  /// the file and the node corresponding to the symbol.
  ///
  /// Local symbols MUST only be used for entities which are local to a Document,
  /// and cannot be accessed from outside the Document.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Symbol : pb::IMessage<Symbol>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Symbol> _parser = new pb::MessageParser<Symbol>(() => new Symbol());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Symbol> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scip.ScipReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Symbol() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Symbol(Symbol other) : this() {
      scheme_ = other.scheme_;
      package_ = other.package_ != null ? other.package_.Clone() : null;
      descriptors_ = other.descriptors_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Symbol Clone() {
      return new Symbol(this);
    }

    /// <summary>Field number for the "scheme" field.</summary>
    public const int SchemeFieldNumber = 1;
    private string scheme_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Scheme {
      get { return scheme_; }
      set {
        scheme_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "package" field.</summary>
    public const int PackageFieldNumber = 2;
    private global::Scip.Package package_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Scip.Package Package {
      get { return package_; }
      set {
        package_ = value;
      }
    }

    /// <summary>Field number for the "descriptors" field.</summary>
    public const int DescriptorsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Scip.SymbolDescriptor> _repeated_descriptors_codec
        = pb::FieldCodec.ForMessage(26, global::Scip.SymbolDescriptor.Parser);
    private readonly pbc::RepeatedField<global::Scip.SymbolDescriptor> descriptors_ = new pbc::RepeatedField<global::Scip.SymbolDescriptor>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Scip.SymbolDescriptor> Descriptors {
      get { return descriptors_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Symbol);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Symbol other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Scheme != other.Scheme) return false;
      if (!object.Equals(Package, other.Package)) return false;
      if(!descriptors_.Equals(other.descriptors_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Scheme.Length != 0) hash ^= Scheme.GetHashCode();
      if (package_ != null) hash ^= Package.GetHashCode();
      hash ^= descriptors_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Scheme.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Scheme);
      }
      if (package_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Package);
      }
      descriptors_.WriteTo(output, _repeated_descriptors_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Scheme.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Scheme);
      }
      if (package_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Package);
      }
      descriptors_.WriteTo(ref output, _repeated_descriptors_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Scheme.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Scheme);
      }
      if (package_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Package);
      }
      size += descriptors_.CalculateSize(_repeated_descriptors_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Symbol other) {
      if (other == null) {
        return;
      }
      if (other.Scheme.Length != 0) {
        Scheme = other.Scheme;
      }
      if (other.package_ != null) {
        if (package_ == null) {
          Package = new global::Scip.Package();
        }
        Package.MergeFrom(other.Package);
      }
      descriptors_.Add(other.descriptors_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Scheme = input.ReadString();
            break;
          }
          case 18: {
            if (package_ == null) {
              Package = new global::Scip.Package();
            }
            input.ReadMessage(Package);
            break;
          }
          case 26: {
            descriptors_.AddEntriesFrom(input, _repeated_descriptors_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Scheme = input.ReadString();
            break;
          }
          case 18: {
            if (package_ == null) {
              Package = new global::Scip.Package();
            }
            input.ReadMessage(Package);
            break;
          }
          case 26: {
            descriptors_.AddEntriesFrom(ref input, _repeated_descriptors_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Unit of packaging and distribution.
  ///
  /// NOTE: This corresponds to a module in Go and JVM languages.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Package : pb::IMessage<Package>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Package> _parser = new pb::MessageParser<Package>(() => new Package());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Package> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scip.ScipReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Package() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Package(Package other) : this() {
      manager_ = other.manager_;
      name_ = other.name_;
      version_ = other.version_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Package Clone() {
      return new Package(this);
    }

    /// <summary>Field number for the "manager" field.</summary>
    public const int ManagerFieldNumber = 1;
    private string manager_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Manager {
      get { return manager_; }
      set {
        manager_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 2;
    private string name_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 3;
    private string version_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Version {
      get { return version_; }
      set {
        version_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Package);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Package other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Manager != other.Manager) return false;
      if (Name != other.Name) return false;
      if (Version != other.Version) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Manager.Length != 0) hash ^= Manager.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Version.Length != 0) hash ^= Version.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Manager.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Manager);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      if (Version.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Version);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Manager.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Manager);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      if (Version.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Version);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Manager.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Manager);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Version.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Version);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Package other) {
      if (other == null) {
        return;
      }
      if (other.Manager.Length != 0) {
        Manager = other.Manager;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Version.Length != 0) {
        Version = other.Version;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Manager = input.ReadString();
            break;
          }
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 26: {
            Version = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Manager = input.ReadString();
            break;
          }
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 26: {
            Version = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SymbolDescriptor : pb::IMessage<SymbolDescriptor>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SymbolDescriptor> _parser = new pb::MessageParser<SymbolDescriptor>(() => new SymbolDescriptor());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SymbolDescriptor> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scip.ScipReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SymbolDescriptor() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SymbolDescriptor(SymbolDescriptor other) : this() {
      name_ = other.name_;
      disambiguator_ = other.disambiguator_;
      suffix_ = other.suffix_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SymbolDescriptor Clone() {
      return new SymbolDescriptor(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "disambiguator" field.</summary>
    public const int DisambiguatorFieldNumber = 2;
    private string disambiguator_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Disambiguator {
      get { return disambiguator_; }
      set {
        disambiguator_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "suffix" field.</summary>
    public const int SuffixFieldNumber = 3;
    private global::Scip.SymbolDescriptor.Types.Suffix suffix_ = global::Scip.SymbolDescriptor.Types.Suffix.UnspecifiedSuffix;
    /// <summary>
    /// NOTE: If you add new fields here, make sure to update the prepareSlot()
    /// function responsible for parsing symbols.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Scip.SymbolDescriptor.Types.Suffix Suffix {
      get { return suffix_; }
      set {
        suffix_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SymbolDescriptor);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SymbolDescriptor other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Disambiguator != other.Disambiguator) return false;
      if (Suffix != other.Suffix) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Disambiguator.Length != 0) hash ^= Disambiguator.GetHashCode();
      if (Suffix != global::Scip.SymbolDescriptor.Types.Suffix.UnspecifiedSuffix) hash ^= Suffix.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Disambiguator.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Disambiguator);
      }
      if (Suffix != global::Scip.SymbolDescriptor.Types.Suffix.UnspecifiedSuffix) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Suffix);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Disambiguator.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Disambiguator);
      }
      if (Suffix != global::Scip.SymbolDescriptor.Types.Suffix.UnspecifiedSuffix) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Suffix);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Disambiguator.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Disambiguator);
      }
      if (Suffix != global::Scip.SymbolDescriptor.Types.Suffix.UnspecifiedSuffix) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Suffix);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SymbolDescriptor other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Disambiguator.Length != 0) {
        Disambiguator = other.Disambiguator;
      }
      if (other.Suffix != global::Scip.SymbolDescriptor.Types.Suffix.UnspecifiedSuffix) {
        Suffix = other.Suffix;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Disambiguator = input.ReadString();
            break;
          }
          case 24: {
            Suffix = (global::Scip.SymbolDescriptor.Types.Suffix) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Disambiguator = input.ReadString();
            break;
          }
          case 24: {
            Suffix = (global::Scip.SymbolDescriptor.Types.Suffix) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the SymbolDescriptor message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum Suffix {
        [pbr::OriginalName("UnspecifiedSuffix")] UnspecifiedSuffix = 0,
        /// <summary>
        /// Unit of code abstraction and/or namespacing.
        ///
        /// NOTE: This corresponds to a package in Go and JVM languages.
        /// </summary>
        [pbr::OriginalName("Namespace")] Namespace = 1,
        /// <summary>
        /// Use Namespace instead.
        /// </summary>
        [global::System.ObsoleteAttribute]
        [pbr::OriginalName("Package", PreferredAlias = false)] Package = 1,
        [pbr::OriginalName("Type")] Type = 2,
        [pbr::OriginalName("Term")] Term = 3,
        [pbr::OriginalName("Method")] Method = 4,
        [pbr::OriginalName("TypeParameter")] TypeParameter = 5,
        [pbr::OriginalName("Parameter")] Parameter = 6,
        /// <summary>
        /// Can be used for any purpose.
        /// </summary>
        [pbr::OriginalName("Meta")] Meta = 7,
        [pbr::OriginalName("Local")] Local = 8,
        [pbr::OriginalName("Macro")] Macro = 9,
      }

    }
    #endregion

  }

  /// <summary>
  /// SymbolInformation defines metadata about a symbol, such as the symbol's
  /// docstring or what package it's defined it.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SymbolInformation : pb::IMessage<SymbolInformation>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SymbolInformation> _parser = new pb::MessageParser<SymbolInformation>(() => new SymbolInformation());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SymbolInformation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scip.ScipReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SymbolInformation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SymbolInformation(SymbolInformation other) : this() {
      symbol_ = other.symbol_;
      documentation_ = other.documentation_.Clone();
      relationships_ = other.relationships_.Clone();
      kind_ = other.kind_;
      displayName_ = other.displayName_;
      signatureDocumentation_ = other.signatureDocumentation_ != null ? other.signatureDocumentation_.Clone() : null;
      enclosingSymbol_ = other.enclosingSymbol_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SymbolInformation Clone() {
      return new SymbolInformation(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private string symbol_ = "";
    /// <summary>
    /// Identifier of this symbol, which can be referenced from `Occurence.symbol`.
    /// The string must be formatted according to the grammar in `Symbol`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "documentation" field.</summary>
    public const int DocumentationFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_documentation_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> documentation_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// (optional, but strongly recommended) The markdown-formatted documentation
    /// for this symbol. Use `SymbolInformation.signature_documentation` to
    /// document the method/class/type signature of this symbol.
    /// Due to historical reasons, indexers may include signature documentation in
    /// this field by rendering markdown code blocks. New indexers should only
    /// include non-code documentation in this field, for example docstrings.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Documentation {
      get { return documentation_; }
    }

    /// <summary>Field number for the "relationships" field.</summary>
    public const int RelationshipsFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Scip.Relationship> _repeated_relationships_codec
        = pb::FieldCodec.ForMessage(34, global::Scip.Relationship.Parser);
    private readonly pbc::RepeatedField<global::Scip.Relationship> relationships_ = new pbc::RepeatedField<global::Scip.Relationship>();
    /// <summary>
    /// (optional) Relationships to other symbols (e.g., implements, type definition).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Scip.Relationship> Relationships {
      get { return relationships_; }
    }

    /// <summary>Field number for the "kind" field.</summary>
    public const int KindFieldNumber = 5;
    private global::Scip.SymbolInformation.Types.Kind kind_ = global::Scip.SymbolInformation.Types.Kind.UnspecifiedKind;
    /// <summary>
    /// The kind of this symbol. Use this field instead of
    /// `SymbolDescriptor.Suffix` to determine whether something is, for example, a
    /// class or a method.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Scip.SymbolInformation.Types.Kind Kind {
      get { return kind_; }
      set {
        kind_ = value;
      }
    }

    /// <summary>Field number for the "display_name" field.</summary>
    public const int DisplayNameFieldNumber = 6;
    private string displayName_ = "";
    /// <summary>
    /// (optional) The name of this symbol as it should be displayed to the user.
    /// For example, the symbol "com/example/MyClass#myMethod(+1)." should have the
    /// display name "myMethod". The `symbol` field is not a reliable source of
    /// the display name for several reasons:
    ///
    /// - Local symbols don't encode the name.
    /// - Some languages have case-insensitive names, so the symbol is all-lowercase.
    /// - The symbol may encode names with special characters that should not be
    ///   displayed to the user.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DisplayName {
      get { return displayName_; }
      set {
        displayName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "signature_documentation" field.</summary>
    public const int SignatureDocumentationFieldNumber = 7;
    private global::Scip.Document signatureDocumentation_;
    /// <summary>
    /// (optional) The signature of this symbol as it's displayed in API
    /// documentation or in hover tooltips. For example, a Java method that adds
    /// two numbers this would have `Document.language = "java"` and `Document.text
    /// = "void add(int a, int b)". The `language` and `text` fields are required
    /// while other fields such as `Documentation.occurrences` can be optionally
    /// included to support hyperlinking referenced symbols in the signature.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Scip.Document SignatureDocumentation {
      get { return signatureDocumentation_; }
      set {
        signatureDocumentation_ = value;
      }
    }

    /// <summary>Field number for the "enclosing_symbol" field.</summary>
    public const int EnclosingSymbolFieldNumber = 8;
    private string enclosingSymbol_ = "";
    /// <summary>
    /// (optional) The enclosing symbol if this is a local symbol.  For non-local
    /// symbols, the enclosing symbol should be parsed from the `symbol` field
    /// using the `Descriptor` grammar.
    ///
    /// The primary use-case for this field is to allow local symbol to be displayed
    /// in a symbol hierarchy for API documentation. It's OK to leave this field
    /// empty for local variables since local variables usually don't belong in API
    /// documentation. However, in the situation that you wish to include a local
    /// symbol in the hierarchy, then you can use `enclosing_symbol` to locate the
    /// "parent" or "owner" of this local symbol. For example, a Java indexer may
    /// choose to use local symbols for private class fields while providing an
    /// `enclosing_symbol` to reference the enclosing class to allow the field to
    /// be part of the class documentation hierarchy. From the perspective of an
    /// author of an indexer, the decision to use a local symbol or global symbol
    /// should exclusively be determined whether the local symbol is accessible
    /// outside the document, not by the capability to find the enclosing
    /// symbol.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string EnclosingSymbol {
      get { return enclosingSymbol_; }
      set {
        enclosingSymbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SymbolInformation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SymbolInformation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      if(!documentation_.Equals(other.documentation_)) return false;
      if(!relationships_.Equals(other.relationships_)) return false;
      if (Kind != other.Kind) return false;
      if (DisplayName != other.DisplayName) return false;
      if (!object.Equals(SignatureDocumentation, other.SignatureDocumentation)) return false;
      if (EnclosingSymbol != other.EnclosingSymbol) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      hash ^= documentation_.GetHashCode();
      hash ^= relationships_.GetHashCode();
      if (Kind != global::Scip.SymbolInformation.Types.Kind.UnspecifiedKind) hash ^= Kind.GetHashCode();
      if (DisplayName.Length != 0) hash ^= DisplayName.GetHashCode();
      if (signatureDocumentation_ != null) hash ^= SignatureDocumentation.GetHashCode();
      if (EnclosingSymbol.Length != 0) hash ^= EnclosingSymbol.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      documentation_.WriteTo(output, _repeated_documentation_codec);
      relationships_.WriteTo(output, _repeated_relationships_codec);
      if (Kind != global::Scip.SymbolInformation.Types.Kind.UnspecifiedKind) {
        output.WriteRawTag(40);
        output.WriteEnum((int) Kind);
      }
      if (DisplayName.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(DisplayName);
      }
      if (signatureDocumentation_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(SignatureDocumentation);
      }
      if (EnclosingSymbol.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(EnclosingSymbol);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      documentation_.WriteTo(ref output, _repeated_documentation_codec);
      relationships_.WriteTo(ref output, _repeated_relationships_codec);
      if (Kind != global::Scip.SymbolInformation.Types.Kind.UnspecifiedKind) {
        output.WriteRawTag(40);
        output.WriteEnum((int) Kind);
      }
      if (DisplayName.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(DisplayName);
      }
      if (signatureDocumentation_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(SignatureDocumentation);
      }
      if (EnclosingSymbol.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(EnclosingSymbol);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      size += documentation_.CalculateSize(_repeated_documentation_codec);
      size += relationships_.CalculateSize(_repeated_relationships_codec);
      if (Kind != global::Scip.SymbolInformation.Types.Kind.UnspecifiedKind) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Kind);
      }
      if (DisplayName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DisplayName);
      }
      if (signatureDocumentation_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SignatureDocumentation);
      }
      if (EnclosingSymbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(EnclosingSymbol);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SymbolInformation other) {
      if (other == null) {
        return;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      documentation_.Add(other.documentation_);
      relationships_.Add(other.relationships_);
      if (other.Kind != global::Scip.SymbolInformation.Types.Kind.UnspecifiedKind) {
        Kind = other.Kind;
      }
      if (other.DisplayName.Length != 0) {
        DisplayName = other.DisplayName;
      }
      if (other.signatureDocumentation_ != null) {
        if (signatureDocumentation_ == null) {
          SignatureDocumentation = new global::Scip.Document();
        }
        SignatureDocumentation.MergeFrom(other.SignatureDocumentation);
      }
      if (other.EnclosingSymbol.Length != 0) {
        EnclosingSymbol = other.EnclosingSymbol;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 26: {
            documentation_.AddEntriesFrom(input, _repeated_documentation_codec);
            break;
          }
          case 34: {
            relationships_.AddEntriesFrom(input, _repeated_relationships_codec);
            break;
          }
          case 40: {
            Kind = (global::Scip.SymbolInformation.Types.Kind) input.ReadEnum();
            break;
          }
          case 50: {
            DisplayName = input.ReadString();
            break;
          }
          case 58: {
            if (signatureDocumentation_ == null) {
              SignatureDocumentation = new global::Scip.Document();
            }
            input.ReadMessage(SignatureDocumentation);
            break;
          }
          case 66: {
            EnclosingSymbol = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 26: {
            documentation_.AddEntriesFrom(ref input, _repeated_documentation_codec);
            break;
          }
          case 34: {
            relationships_.AddEntriesFrom(ref input, _repeated_relationships_codec);
            break;
          }
          case 40: {
            Kind = (global::Scip.SymbolInformation.Types.Kind) input.ReadEnum();
            break;
          }
          case 50: {
            DisplayName = input.ReadString();
            break;
          }
          case 58: {
            if (signatureDocumentation_ == null) {
              SignatureDocumentation = new global::Scip.Document();
            }
            input.ReadMessage(SignatureDocumentation);
            break;
          }
          case 66: {
            EnclosingSymbol = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the SymbolInformation message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// (optional) Kind represents the fine-grained category of a symbol, suitable for presenting
      /// information about the symbol's meaning in the language.
      ///
      /// For example:
      /// - A Java method would have the kind `Method` while a Go function would
      ///   have the kind `Function`, even if the symbols for these use the same
      ///   syntax for the descriptor `SymbolDescriptor.Suffix.Method`.
      /// - A Go struct has the symbol kind `Struct` while a Java class has
      ///   the symbol kind `Class` even if they both have the same descriptor:
      ///   `SymbolDescriptor.Suffix.Type`.
      ///
      /// Since Kind is more fine-grained than Suffix:
      /// - If two symbols have the same Kind, they should share the same Suffix.
      /// - If two symbols have different Suffixes, they should have different Kinds.
      /// </summary>
      public enum Kind {
        [pbr::OriginalName("UnspecifiedKind")] UnspecifiedKind = 0,
        /// <summary>
        /// A method which may or may not have a body. For Java, Kotlin etc.
        /// </summary>
        [pbr::OriginalName("AbstractMethod")] AbstractMethod = 66,
        /// <summary>
        /// For Ruby's attr_accessor
        /// </summary>
        [pbr::OriginalName("Accessor")] Accessor = 72,
        [pbr::OriginalName("Array")] Array = 1,
        /// <summary>
        /// For Alloy
        /// </summary>
        [pbr::OriginalName("Assertion")] Assertion = 2,
        [pbr::OriginalName("AssociatedType")] AssociatedType = 3,
        /// <summary>
        /// For C++
        /// </summary>
        [pbr::OriginalName("Attribute")] Attribute = 4,
        /// <summary>
        /// For Lean
        /// </summary>
        [pbr::OriginalName("Axiom")] Axiom = 5,
        [pbr::OriginalName("Boolean")] Boolean = 6,
        [pbr::OriginalName("Class")] Class = 7,
        /// <summary>
        /// For C++
        /// </summary>
        [pbr::OriginalName("Concept")] Concept = 86,
        [pbr::OriginalName("Constant")] Constant = 8,
        [pbr::OriginalName("Constructor")] Constructor = 9,
        /// <summary>
        /// For Solidity
        /// </summary>
        [pbr::OriginalName("Contract")] Contract = 62,
        /// <summary>
        /// For Haskell
        /// </summary>
        [pbr::OriginalName("DataFamily")] DataFamily = 10,
        /// <summary>
        /// For C# and F#
        /// </summary>
        [pbr::OriginalName("Delegate")] Delegate = 73,
        [pbr::OriginalName("Enum")] Enum = 11,
        [pbr::OriginalName("EnumMember")] EnumMember = 12,
        [pbr::OriginalName("Error")] Error = 63,
        [pbr::OriginalName("Event")] Event = 13,
        /// <summary>
        /// For Dart
        /// </summary>
        [pbr::OriginalName("Extension")] Extension = 84,
        /// <summary>
        /// For Alloy
        /// </summary>
        [pbr::OriginalName("Fact")] Fact = 14,
        [pbr::OriginalName("Field")] Field = 15,
        [pbr::OriginalName("File")] File = 16,
        [pbr::OriginalName("Function")] Function = 17,
        /// <summary>
        /// For 'get' in Swift, 'attr_reader' in Ruby
        /// </summary>
        [pbr::OriginalName("Getter")] Getter = 18,
        /// <summary>
        /// For Raku
        /// </summary>
        [pbr::OriginalName("Grammar")] Grammar = 19,
        /// <summary>
        /// For Purescript and Lean
        /// </summary>
        [pbr::OriginalName("Instance")] Instance = 20,
        [pbr::OriginalName("Interface")] Interface = 21,
        [pbr::OriginalName("Key")] Key = 22,
        /// <summary>
        /// For Racket
        /// </summary>
        [pbr::OriginalName("Lang")] Lang = 23,
        /// <summary>
        /// For Lean
        /// </summary>
        [pbr::OriginalName("Lemma")] Lemma = 24,
        /// <summary>
        /// For solidity
        /// </summary>
        [pbr::OriginalName("Library")] Library = 64,
        [pbr::OriginalName("Macro")] Macro = 25,
        [pbr::OriginalName("Method")] Method = 26,
        /// <summary>
        /// For Ruby
        /// </summary>
        [pbr::OriginalName("MethodAlias")] MethodAlias = 74,
        /// <summary>
        /// Analogous to 'ThisParameter' and 'SelfParameter', but for languages
        /// like Go where the receiver doesn't have a conventional name.
        /// </summary>
        [pbr::OriginalName("MethodReceiver")] MethodReceiver = 27,
        /// <summary>
        /// Analogous to 'AbstractMethod', for Go.
        /// </summary>
        [pbr::OriginalName("MethodSpecification")] MethodSpecification = 67,
        /// <summary>
        /// For Protobuf
        /// </summary>
        [pbr::OriginalName("Message")] Message = 28,
        /// <summary>
        /// For Dart
        /// </summary>
        [pbr::OriginalName("Mixin")] Mixin = 85,
        /// <summary>
        /// For Solidity
        /// </summary>
        [pbr::OriginalName("Modifier")] Modifier = 65,
        [pbr::OriginalName("Module")] Module = 29,
        [pbr::OriginalName("Namespace")] Namespace = 30,
        [pbr::OriginalName("Null")] Null = 31,
        [pbr::OriginalName("Number")] Number = 32,
        [pbr::OriginalName("Object")] Object = 33,
        [pbr::OriginalName("Operator")] Operator = 34,
        [pbr::OriginalName("Package")] Package = 35,
        [pbr::OriginalName("PackageObject")] PackageObject = 36,
        [pbr::OriginalName("Parameter")] Parameter = 37,
        [pbr::OriginalName("ParameterLabel")] ParameterLabel = 38,
        /// <summary>
        /// For Haskell's PatternSynonyms
        /// </summary>
        [pbr::OriginalName("Pattern")] Pattern = 39,
        /// <summary>
        /// For Alloy
        /// </summary>
        [pbr::OriginalName("Predicate")] Predicate = 40,
        [pbr::OriginalName("Property")] Property = 41,
        /// <summary>
        /// Analogous to 'Trait' and 'TypeClass', for Swift and Objective-C
        /// </summary>
        [pbr::OriginalName("Protocol")] Protocol = 42,
        /// <summary>
        /// Analogous to 'AbstractMethod', for Swift and Objective-C.
        /// </summary>
        [pbr::OriginalName("ProtocolMethod")] ProtocolMethod = 68,
        /// <summary>
        /// Analogous to 'AbstractMethod', for C++.
        /// </summary>
        [pbr::OriginalName("PureVirtualMethod")] PureVirtualMethod = 69,
        /// <summary>
        /// For Haskell
        /// </summary>
        [pbr::OriginalName("Quasiquoter")] Quasiquoter = 43,
        /// <summary>
        /// 'self' in Python, Rust, Swift etc.
        /// </summary>
        [pbr::OriginalName("SelfParameter")] SelfParameter = 44,
        /// <summary>
        /// For 'set' in Swift, 'attr_writer' in Ruby
        /// </summary>
        [pbr::OriginalName("Setter")] Setter = 45,
        /// <summary>
        /// For Alloy, analogous to 'Struct'.
        /// </summary>
        [pbr::OriginalName("Signature")] Signature = 46,
        /// <summary>
        /// For Ruby
        /// </summary>
        [pbr::OriginalName("SingletonClass")] SingletonClass = 75,
        /// <summary>
        /// Analogous to 'StaticMethod', for Ruby.
        /// </summary>
        [pbr::OriginalName("SingletonMethod")] SingletonMethod = 76,
        /// <summary>
        /// Analogous to 'StaticField', for C++
        /// </summary>
        [pbr::OriginalName("StaticDataMember")] StaticDataMember = 77,
        /// <summary>
        /// For C#
        /// </summary>
        [pbr::OriginalName("StaticEvent")] StaticEvent = 78,
        /// <summary>
        /// For C#
        /// </summary>
        [pbr::OriginalName("StaticField")] StaticField = 79,
        /// <summary>
        /// For Java, C#, C++ etc.
        /// </summary>
        [pbr::OriginalName("StaticMethod")] StaticMethod = 80,
        /// <summary>
        /// For C#, TypeScript etc.
        /// </summary>
        [pbr::OriginalName("StaticProperty")] StaticProperty = 81,
        /// <summary>
        /// For C, C++
        /// </summary>
        [pbr::OriginalName("StaticVariable")] StaticVariable = 82,
        [pbr::OriginalName("String")] String = 48,
        [pbr::OriginalName("Struct")] Struct = 49,
        /// <summary>
        /// For Swift
        /// </summary>
        [pbr::OriginalName("Subscript")] Subscript = 47,
        /// <summary>
        /// For Lean
        /// </summary>
        [pbr::OriginalName("Tactic")] Tactic = 50,
        /// <summary>
        /// For Lean
        /// </summary>
        [pbr::OriginalName("Theorem")] Theorem = 51,
        /// <summary>
        /// Method receiver for languages
        /// 'this' in JavaScript, C++, Java etc.
        /// </summary>
        [pbr::OriginalName("ThisParameter")] ThisParameter = 52,
        /// <summary>
        /// Analogous to 'Protocol' and 'TypeClass', for Rust, Scala etc.
        /// </summary>
        [pbr::OriginalName("Trait")] Trait = 53,
        /// <summary>
        /// Analogous to 'AbstractMethod', for Rust, Scala etc.
        /// </summary>
        [pbr::OriginalName("TraitMethod")] TraitMethod = 70,
        /// <summary>
        /// Data type definition for languages like OCaml which use `type`
        /// rather than separate keywords like `struct` and `enum`.
        /// </summary>
        [pbr::OriginalName("Type")] Type = 54,
        [pbr::OriginalName("TypeAlias")] TypeAlias = 55,
        /// <summary>
        /// Analogous to 'Trait' and 'Protocol', for Haskell, Purescript etc.
        /// </summary>
        [pbr::OriginalName("TypeClass")] TypeClass = 56,
        /// <summary>
        /// Analogous to 'AbstractMethod', for Haskell, Purescript etc.
        /// </summary>
        [pbr::OriginalName("TypeClassMethod")] TypeClassMethod = 71,
        /// <summary>
        /// For Haskell
        /// </summary>
        [pbr::OriginalName("TypeFamily")] TypeFamily = 57,
        [pbr::OriginalName("TypeParameter")] TypeParameter = 58,
        /// <summary>
        /// For C, C++, Capn Proto
        /// </summary>
        [pbr::OriginalName("Union")] Union = 59,
        [pbr::OriginalName("Value")] Value = 60,
        /// <summary>
        /// Next = 87;
        /// Feel free to open a PR proposing new language-specific kinds.
        /// </summary>
        [pbr::OriginalName("Variable")] Variable = 61,
      }

    }
    #endregion

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Relationship : pb::IMessage<Relationship>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Relationship> _parser = new pb::MessageParser<Relationship>(() => new Relationship());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Relationship> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scip.ScipReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Relationship() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Relationship(Relationship other) : this() {
      symbol_ = other.symbol_;
      isReference_ = other.isReference_;
      isImplementation_ = other.isImplementation_;
      isTypeDefinition_ = other.isTypeDefinition_;
      isDefinition_ = other.isDefinition_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Relationship Clone() {
      return new Relationship(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "is_reference" field.</summary>
    public const int IsReferenceFieldNumber = 2;
    private bool isReference_;
    /// <summary>
    /// When resolving "Find references", this field documents what other symbols
    /// should be included together with this symbol. For example, consider the
    /// following TypeScript code that defines two symbols `Animal#sound()` and
    /// `Dog#sound()`:
    /// ```ts
    /// interface Animal {
    ///           ^^^^^^ definition Animal#
    ///   sound(): string
    ///   ^^^^^ definition Animal#sound()
    /// }
    /// class Dog implements Animal {
    ///       ^^^ definition Dog#, relationships = [{symbol: "Animal#", is_implementation: true}]
    ///   public sound(): string { return "woof" }
    ///          ^^^^^ definition Dog#sound(), references_symbols = Animal#sound(), relationships = [{symbol: "Animal#sound()", is_implementation:true, is_reference: true}]
    /// }
    /// const animal: Animal = new Dog()
    ///               ^^^^^^ reference Animal#
    /// console.log(animal.sound())
    ///                    ^^^^^ reference Animal#sound()
    /// ```
    /// Doing "Find references" on the symbol `Animal#sound()` should return
    /// references to the `Dog#sound()` method as well. Vice-versa, doing "Find
    /// references" on the `Dog#sound()` method should include references to the
    /// `Animal#sound()` method as well.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsReference {
      get { return isReference_; }
      set {
        isReference_ = value;
      }
    }

    /// <summary>Field number for the "is_implementation" field.</summary>
    public const int IsImplementationFieldNumber = 3;
    private bool isImplementation_;
    /// <summary>
    /// Similar to `is_reference` but for "Find implementations".
    /// It's common for `is_implementation` and `is_reference` to both be true but
    /// it's not always the case.
    /// In the TypeScript example above, observe that `Dog#` has an
    /// `is_implementation` relationship with `"Animal#"` but not `is_reference`.
    /// This is because "Find references" on the "Animal#" symbol should not return
    /// "Dog#". We only want "Dog#" to return as a result for "Find
    /// implementations" on the "Animal#" symbol.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsImplementation {
      get { return isImplementation_; }
      set {
        isImplementation_ = value;
      }
    }

    /// <summary>Field number for the "is_type_definition" field.</summary>
    public const int IsTypeDefinitionFieldNumber = 4;
    private bool isTypeDefinition_;
    /// <summary>
    /// Similar to `references_symbols` but for "Go to type definition".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsTypeDefinition {
      get { return isTypeDefinition_; }
      set {
        isTypeDefinition_ = value;
      }
    }

    /// <summary>Field number for the "is_definition" field.</summary>
    public const int IsDefinitionFieldNumber = 5;
    private bool isDefinition_;
    /// <summary>
    /// Allows overriding the behavior of "Go to definition" and "Find references"
    /// for symbols which do not have a definition of their own or could
    /// potentially have multiple definitions.
    ///
    /// For example, in a language with single inheritance and no field overriding,
    /// inherited fields can reuse the same symbol as the ancestor which declares
    /// the field. In such a situation, is_definition is not needed.
    ///
    /// On the other hand, in languages with single inheritance and some form
    /// of mixins, you can use is_definition to relate the symbol to the
    /// matching symbol in ancestor classes, and is_reference to relate the
    /// symbol to the matching symbol in mixins.
    ///
    /// NOTE: At the moment, due to limitations of the SCIP to LSIF conversion,
    /// only global symbols in an index are allowed to use is_definition.
    /// The relationship may not get recorded if either symbol is local.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsDefinition {
      get { return isDefinition_; }
      set {
        isDefinition_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Relationship);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Relationship other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      if (IsReference != other.IsReference) return false;
      if (IsImplementation != other.IsImplementation) return false;
      if (IsTypeDefinition != other.IsTypeDefinition) return false;
      if (IsDefinition != other.IsDefinition) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (IsReference != false) hash ^= IsReference.GetHashCode();
      if (IsImplementation != false) hash ^= IsImplementation.GetHashCode();
      if (IsTypeDefinition != false) hash ^= IsTypeDefinition.GetHashCode();
      if (IsDefinition != false) hash ^= IsDefinition.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (IsReference != false) {
        output.WriteRawTag(16);
        output.WriteBool(IsReference);
      }
      if (IsImplementation != false) {
        output.WriteRawTag(24);
        output.WriteBool(IsImplementation);
      }
      if (IsTypeDefinition != false) {
        output.WriteRawTag(32);
        output.WriteBool(IsTypeDefinition);
      }
      if (IsDefinition != false) {
        output.WriteRawTag(40);
        output.WriteBool(IsDefinition);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (IsReference != false) {
        output.WriteRawTag(16);
        output.WriteBool(IsReference);
      }
      if (IsImplementation != false) {
        output.WriteRawTag(24);
        output.WriteBool(IsImplementation);
      }
      if (IsTypeDefinition != false) {
        output.WriteRawTag(32);
        output.WriteBool(IsTypeDefinition);
      }
      if (IsDefinition != false) {
        output.WriteRawTag(40);
        output.WriteBool(IsDefinition);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (IsReference != false) {
        size += 1 + 1;
      }
      if (IsImplementation != false) {
        size += 1 + 1;
      }
      if (IsTypeDefinition != false) {
        size += 1 + 1;
      }
      if (IsDefinition != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Relationship other) {
      if (other == null) {
        return;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.IsReference != false) {
        IsReference = other.IsReference;
      }
      if (other.IsImplementation != false) {
        IsImplementation = other.IsImplementation;
      }
      if (other.IsTypeDefinition != false) {
        IsTypeDefinition = other.IsTypeDefinition;
      }
      if (other.IsDefinition != false) {
        IsDefinition = other.IsDefinition;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            IsReference = input.ReadBool();
            break;
          }
          case 24: {
            IsImplementation = input.ReadBool();
            break;
          }
          case 32: {
            IsTypeDefinition = input.ReadBool();
            break;
          }
          case 40: {
            IsDefinition = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            IsReference = input.ReadBool();
            break;
          }
          case 24: {
            IsImplementation = input.ReadBool();
            break;
          }
          case 32: {
            IsTypeDefinition = input.ReadBool();
            break;
          }
          case 40: {
            IsDefinition = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Occurrence associates a source position with a symbol and/or highlighting
  /// information.
  ///
  /// If possible, indexers should try to bundle logically related information
  /// across occurrences into a single occurrence to reduce payload sizes.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Occurrence : pb::IMessage<Occurrence>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Occurrence> _parser = new pb::MessageParser<Occurrence>(() => new Occurrence());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Occurrence> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scip.ScipReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Occurrence() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Occurrence(Occurrence other) : this() {
      range_ = other.range_.Clone();
      symbol_ = other.symbol_;
      symbolRoles_ = other.symbolRoles_;
      overrideDocumentation_ = other.overrideDocumentation_.Clone();
      syntaxKind_ = other.syntaxKind_;
      diagnostics_ = other.diagnostics_.Clone();
      enclosingRange_ = other.enclosingRange_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Occurrence Clone() {
      return new Occurrence(this);
    }

    /// <summary>Field number for the "range" field.</summary>
    public const int RangeFieldNumber = 1;
    private static readonly pb::FieldCodec<int> _repeated_range_codec
        = pb::FieldCodec.ForInt32(10);
    private readonly pbc::RepeatedField<int> range_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// Half-open [start, end) range of this occurrence. Must be exactly three or four
    /// elements:
    ///
    /// - Four elements: `[startLine, startCharacter, endLine, endCharacter]`
    /// - Three elements: `[startLine, startCharacter, endCharacter]`. The end line
    ///   is inferred to have the same value as the start line.
    ///
    /// It is allowed for the range to be empty (i.e. start==end).
    ///
    /// Line numbers and characters are always 0-based. Make sure to increment the
    /// line/character values before displaying them in an editor-like UI because
    /// editors conventionally use 1-based numbers.
    ///
    /// The 'character' value is interpreted based on the PositionEncoding for
    /// the Document.
    ///
    /// Historical note: the original draft of this schema had a `Range` message
    /// type with `start` and `end` fields of type `Position`, mirroring LSP.
    /// Benchmarks revealed that this encoding was inefficient and that we could
    /// reduce the total payload size of an index by 50% by using `repeated int32`
    /// instead. The `repeated int32` encoding is admittedly more embarrassing to
    /// work with in some programming languages but we hope the performance
    /// improvements make up for it.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> Range {
      get { return range_; }
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 2;
    private string symbol_ = "";
    /// <summary>
    /// (optional) The symbol that appears at this position. See
    /// `SymbolInformation.symbol` for how to format symbols as strings.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "symbol_roles" field.</summary>
    public const int SymbolRolesFieldNumber = 3;
    private int symbolRoles_;
    /// <summary>
    /// (optional) Bitset containing `SymbolRole`s in this occurrence.
    /// See `SymbolRole`'s documentation for how to read and write this field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int SymbolRoles {
      get { return symbolRoles_; }
      set {
        symbolRoles_ = value;
      }
    }

    /// <summary>Field number for the "override_documentation" field.</summary>
    public const int OverrideDocumentationFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_overrideDocumentation_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> overrideDocumentation_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// (optional) CommonMark-formatted documentation for this specific range. If
    /// empty, the `Symbol.documentation` field is used instead. One example
    /// where this field might be useful is when the symbol represents a generic
    /// function (with abstract type parameters such as `List&lt;T>`) and at this
    /// occurrence we know the exact values (such as `List&lt;String>`).
    ///
    /// This field can also be used for dynamically or gradually typed languages,
    /// which commonly allow for type-changing assignment.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> OverrideDocumentation {
      get { return overrideDocumentation_; }
    }

    /// <summary>Field number for the "syntax_kind" field.</summary>
    public const int SyntaxKindFieldNumber = 5;
    private global::Scip.SyntaxKind syntaxKind_ = global::Scip.SyntaxKind.UnspecifiedSyntaxKind;
    /// <summary>
    /// (optional) What syntax highlighting class should be used for this range?
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Scip.SyntaxKind SyntaxKind {
      get { return syntaxKind_; }
      set {
        syntaxKind_ = value;
      }
    }

    /// <summary>Field number for the "diagnostics" field.</summary>
    public const int DiagnosticsFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Scip.Diagnostic> _repeated_diagnostics_codec
        = pb::FieldCodec.ForMessage(50, global::Scip.Diagnostic.Parser);
    private readonly pbc::RepeatedField<global::Scip.Diagnostic> diagnostics_ = new pbc::RepeatedField<global::Scip.Diagnostic>();
    /// <summary>
    /// (optional) Diagnostics that have been reported for this specific range.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Scip.Diagnostic> Diagnostics {
      get { return diagnostics_; }
    }

    /// <summary>Field number for the "enclosing_range" field.</summary>
    public const int EnclosingRangeFieldNumber = 7;
    private static readonly pb::FieldCodec<int> _repeated_enclosingRange_codec
        = pb::FieldCodec.ForInt32(58);
    private readonly pbc::RepeatedField<int> enclosingRange_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// (optional) Using the same encoding as the sibling `range` field, half-open
    /// source range of the nearest non-trivial enclosing AST node. This range must
    /// enclose the `range` field. Example applications that make use of the
    /// enclosing_range field:
    ///
    /// - Call hierarchies: to determine what symbols are references from the body
    ///   of a function
    /// - Symbol outline: to display breadcrumbs from the cursor position to the
    ///   root of the file
    /// - Expand selection: to select the nearest enclosing AST node.
    /// - Highlight range: to indicate the AST expression that is associated with a
    ///   hover popover
    ///
    /// For definition occurrences, the enclosing range should indicate the
    /// start/end bounds of the entire definition AST node, including
    /// documentation.
    /// ```
    /// const n = 3
    ///       ^ range
    /// ^^^^^^^^^^^ enclosing_range
    ///
    /// /** Parses the string into something */
    /// ^ enclosing_range start --------------------------------------|
    /// function parse(input string): string {                        |
    ///          ^^^^^ range                                          |
    ///     return input.slice(n)                                     |
    /// }                                                             |
    /// ^ enclosing_range end &lt;---------------------------------------|
    /// ```
    ///
    /// Any attributes/decorators/attached macros should also be part of the
    /// enclosing range.
    ///
    /// ```python
    /// @cache
    /// ^ enclosing_range start---------------------|
    /// def factorial(n):                           |
    ///     return n * factorial(n-1) if n else 1   |
    /// &lt; enclosing_range end-----------------------|
    ///
    /// ```
    ///
    /// For reference occurrences, the enclosing range should indicate the start/end
    /// bounds of the parent expression.
    /// ```
    /// const a = a.b
    ///             ^ range
    ///           ^^^ enclosing_range
    /// const b = a.b(41).f(42).g(43)
    ///                   ^ range
    ///           ^^^^^^^^^^^^^ enclosing_range
    /// ```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> EnclosingRange {
      get { return enclosingRange_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Occurrence);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Occurrence other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!range_.Equals(other.range_)) return false;
      if (Symbol != other.Symbol) return false;
      if (SymbolRoles != other.SymbolRoles) return false;
      if(!overrideDocumentation_.Equals(other.overrideDocumentation_)) return false;
      if (SyntaxKind != other.SyntaxKind) return false;
      if(!diagnostics_.Equals(other.diagnostics_)) return false;
      if(!enclosingRange_.Equals(other.enclosingRange_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= range_.GetHashCode();
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (SymbolRoles != 0) hash ^= SymbolRoles.GetHashCode();
      hash ^= overrideDocumentation_.GetHashCode();
      if (SyntaxKind != global::Scip.SyntaxKind.UnspecifiedSyntaxKind) hash ^= SyntaxKind.GetHashCode();
      hash ^= diagnostics_.GetHashCode();
      hash ^= enclosingRange_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      range_.WriteTo(output, _repeated_range_codec);
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (SymbolRoles != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(SymbolRoles);
      }
      overrideDocumentation_.WriteTo(output, _repeated_overrideDocumentation_codec);
      if (SyntaxKind != global::Scip.SyntaxKind.UnspecifiedSyntaxKind) {
        output.WriteRawTag(40);
        output.WriteEnum((int) SyntaxKind);
      }
      diagnostics_.WriteTo(output, _repeated_diagnostics_codec);
      enclosingRange_.WriteTo(output, _repeated_enclosingRange_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      range_.WriteTo(ref output, _repeated_range_codec);
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (SymbolRoles != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(SymbolRoles);
      }
      overrideDocumentation_.WriteTo(ref output, _repeated_overrideDocumentation_codec);
      if (SyntaxKind != global::Scip.SyntaxKind.UnspecifiedSyntaxKind) {
        output.WriteRawTag(40);
        output.WriteEnum((int) SyntaxKind);
      }
      diagnostics_.WriteTo(ref output, _repeated_diagnostics_codec);
      enclosingRange_.WriteTo(ref output, _repeated_enclosingRange_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += range_.CalculateSize(_repeated_range_codec);
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (SymbolRoles != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(SymbolRoles);
      }
      size += overrideDocumentation_.CalculateSize(_repeated_overrideDocumentation_codec);
      if (SyntaxKind != global::Scip.SyntaxKind.UnspecifiedSyntaxKind) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SyntaxKind);
      }
      size += diagnostics_.CalculateSize(_repeated_diagnostics_codec);
      size += enclosingRange_.CalculateSize(_repeated_enclosingRange_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Occurrence other) {
      if (other == null) {
        return;
      }
      range_.Add(other.range_);
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.SymbolRoles != 0) {
        SymbolRoles = other.SymbolRoles;
      }
      overrideDocumentation_.Add(other.overrideDocumentation_);
      if (other.SyntaxKind != global::Scip.SyntaxKind.UnspecifiedSyntaxKind) {
        SyntaxKind = other.SyntaxKind;
      }
      diagnostics_.Add(other.diagnostics_);
      enclosingRange_.Add(other.enclosingRange_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            range_.AddEntriesFrom(input, _repeated_range_codec);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
          case 24: {
            SymbolRoles = input.ReadInt32();
            break;
          }
          case 34: {
            overrideDocumentation_.AddEntriesFrom(input, _repeated_overrideDocumentation_codec);
            break;
          }
          case 40: {
            SyntaxKind = (global::Scip.SyntaxKind) input.ReadEnum();
            break;
          }
          case 50: {
            diagnostics_.AddEntriesFrom(input, _repeated_diagnostics_codec);
            break;
          }
          case 58:
          case 56: {
            enclosingRange_.AddEntriesFrom(input, _repeated_enclosingRange_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10:
          case 8: {
            range_.AddEntriesFrom(ref input, _repeated_range_codec);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
          case 24: {
            SymbolRoles = input.ReadInt32();
            break;
          }
          case 34: {
            overrideDocumentation_.AddEntriesFrom(ref input, _repeated_overrideDocumentation_codec);
            break;
          }
          case 40: {
            SyntaxKind = (global::Scip.SyntaxKind) input.ReadEnum();
            break;
          }
          case 50: {
            diagnostics_.AddEntriesFrom(ref input, _repeated_diagnostics_codec);
            break;
          }
          case 58:
          case 56: {
            enclosingRange_.AddEntriesFrom(ref input, _repeated_enclosingRange_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents a diagnostic, such as a compiler error or warning, which should be
  /// reported for a document.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Diagnostic : pb::IMessage<Diagnostic>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Diagnostic> _parser = new pb::MessageParser<Diagnostic>(() => new Diagnostic());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Diagnostic> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scip.ScipReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Diagnostic() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Diagnostic(Diagnostic other) : this() {
      severity_ = other.severity_;
      code_ = other.code_;
      message_ = other.message_;
      source_ = other.source_;
      tags_ = other.tags_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Diagnostic Clone() {
      return new Diagnostic(this);
    }

    /// <summary>Field number for the "severity" field.</summary>
    public const int SeverityFieldNumber = 1;
    private global::Scip.Severity severity_ = global::Scip.Severity.UnspecifiedSeverity;
    /// <summary>
    /// Should this diagnostic be reported as an error, warning, info, or hint?
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Scip.Severity Severity {
      get { return severity_; }
      set {
        severity_ = value;
      }
    }

    /// <summary>Field number for the "code" field.</summary>
    public const int CodeFieldNumber = 2;
    private string code_ = "";
    /// <summary>
    /// (optional) Code of this diagnostic, which might appear in the user interface.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Code {
      get { return code_; }
      set {
        code_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 3;
    private string message_ = "";
    /// <summary>
    /// Message of this diagnostic.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Message {
      get { return message_; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "source" field.</summary>
    public const int SourceFieldNumber = 4;
    private string source_ = "";
    /// <summary>
    /// (optional) Human-readable string describing the source of this diagnostic, e.g.
    /// 'typescript' or 'super lint'.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Source {
      get { return source_; }
      set {
        source_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "tags" field.</summary>
    public const int TagsFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Scip.DiagnosticTag> _repeated_tags_codec
        = pb::FieldCodec.ForEnum(42, x => (int) x, x => (global::Scip.DiagnosticTag) x);
    private readonly pbc::RepeatedField<global::Scip.DiagnosticTag> tags_ = new pbc::RepeatedField<global::Scip.DiagnosticTag>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Scip.DiagnosticTag> Tags {
      get { return tags_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Diagnostic);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Diagnostic other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Severity != other.Severity) return false;
      if (Code != other.Code) return false;
      if (Message != other.Message) return false;
      if (Source != other.Source) return false;
      if(!tags_.Equals(other.tags_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Severity != global::Scip.Severity.UnspecifiedSeverity) hash ^= Severity.GetHashCode();
      if (Code.Length != 0) hash ^= Code.GetHashCode();
      if (Message.Length != 0) hash ^= Message.GetHashCode();
      if (Source.Length != 0) hash ^= Source.GetHashCode();
      hash ^= tags_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Severity != global::Scip.Severity.UnspecifiedSeverity) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Severity);
      }
      if (Code.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Code);
      }
      if (Message.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Message);
      }
      if (Source.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Source);
      }
      tags_.WriteTo(output, _repeated_tags_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Severity != global::Scip.Severity.UnspecifiedSeverity) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Severity);
      }
      if (Code.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Code);
      }
      if (Message.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Message);
      }
      if (Source.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Source);
      }
      tags_.WriteTo(ref output, _repeated_tags_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Severity != global::Scip.Severity.UnspecifiedSeverity) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Severity);
      }
      if (Code.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Code);
      }
      if (Message.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (Source.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Source);
      }
      size += tags_.CalculateSize(_repeated_tags_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Diagnostic other) {
      if (other == null) {
        return;
      }
      if (other.Severity != global::Scip.Severity.UnspecifiedSeverity) {
        Severity = other.Severity;
      }
      if (other.Code.Length != 0) {
        Code = other.Code;
      }
      if (other.Message.Length != 0) {
        Message = other.Message;
      }
      if (other.Source.Length != 0) {
        Source = other.Source;
      }
      tags_.Add(other.tags_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Severity = (global::Scip.Severity) input.ReadEnum();
            break;
          }
          case 18: {
            Code = input.ReadString();
            break;
          }
          case 26: {
            Message = input.ReadString();
            break;
          }
          case 34: {
            Source = input.ReadString();
            break;
          }
          case 42:
          case 40: {
            tags_.AddEntriesFrom(input, _repeated_tags_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Severity = (global::Scip.Severity) input.ReadEnum();
            break;
          }
          case 18: {
            Code = input.ReadString();
            break;
          }
          case 26: {
            Message = input.ReadString();
            break;
          }
          case 34: {
            Source = input.ReadString();
            break;
          }
          case 42:
          case 40: {
            tags_.AddEntriesFrom(ref input, _repeated_tags_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
