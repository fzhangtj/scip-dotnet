// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: scip.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Scip {

  /// <summary>Holder for reflection information generated from scip.proto</summary>
  public static partial class ScipReflection {

    #region Descriptor
    /// <summary>File descriptor for scip.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ScipReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CgpzY2lwLnByb3RvEgRzY2lwIn8KBUluZGV4EiAKCG1ldGFkYXRhGAEgASgL",
            "Mg4uc2NpcC5NZXRhZGF0YRIhCglkb2N1bWVudHMYAiADKAsyDi5zY2lwLkRv",
            "Y3VtZW50EjEKEGV4dGVybmFsX3N5bWJvbHMYAyADKAsyFy5zY2lwLlN5bWJv",
            "bEluZm9ybWF0aW9uIp8BCghNZXRhZGF0YRImCgd2ZXJzaW9uGAEgASgOMhUu",
            "c2NpcC5Qcm90b2NvbFZlcnNpb24SIQoJdG9vbF9pbmZvGAIgASgLMg4uc2Np",
            "cC5Ub29sSW5mbxIUCgxwcm9qZWN0X3Jvb3QYAyABKAkSMgoWdGV4dF9kb2N1",
            "bWVudF9lbmNvZGluZxgEIAEoDjISLnNjaXAuVGV4dEVuY29kaW5nIjwKCFRv",
            "b2xJbmZvEgwKBG5hbWUYASABKAkSDwoHdmVyc2lvbhgCIAEoCRIRCglhcmd1",
            "bWVudHMYAyADKAkihAEKCERvY3VtZW50EhAKCGxhbmd1YWdlGAQgASgJEhUK",
            "DXJlbGF0aXZlX3BhdGgYASABKAkSJQoLb2NjdXJyZW5jZXMYAiADKAsyEC5z",
            "Y2lwLk9jY3VycmVuY2USKAoHc3ltYm9scxgDIAMoCzIXLnNjaXAuU3ltYm9s",
            "SW5mb3JtYXRpb24iZQoGU3ltYm9sEg4KBnNjaGVtZRgBIAEoCRIeCgdwYWNr",
            "YWdlGAIgASgLMg0uc2NpcC5QYWNrYWdlEisKC2Rlc2NyaXB0b3JzGAMgAygL",
            "MhYuc2NpcC5TeW1ib2xEZXNjcmlwdG9yIjkKB1BhY2thZ2USDwoHbWFuYWdl",
            "chgBIAEoCRIMCgRuYW1lGAIgASgJEg8KB3ZlcnNpb24YAyABKAkijgIKEFN5",
            "bWJvbERlc2NyaXB0b3ISDAoEbmFtZRgBIAEoCRIVCg1kaXNhbWJpZ3VhdG9y",
            "GAIgASgJEi0KBnN1ZmZpeBgDIAEoDjIdLnNjaXAuU3ltYm9sRGVzY3JpcHRv",
            "ci5TdWZmaXgipQEKBlN1ZmZpeBIVChFVbnNwZWNpZmllZFN1ZmZpeBAAEg0K",
            "CU5hbWVzcGFjZRABEg8KB1BhY2thZ2UQARoCCAESCAoEVHlwZRACEggKBFRl",
            "cm0QAxIKCgZNZXRob2QQBBIRCg1UeXBlUGFyYW1ldGVyEAUSDQoJUGFyYW1l",
            "dGVyEAYSCQoFTWFjcm8QCRIICgRNZXRhEAcSCQoFTG9jYWwQCBoCEAEiZQoR",
            "U3ltYm9sSW5mb3JtYXRpb24SDgoGc3ltYm9sGAEgASgJEhUKDWRvY3VtZW50",
            "YXRpb24YAyADKAkSKQoNcmVsYXRpb25zaGlwcxgEIAMoCzISLnNjaXAuUmVs",
            "YXRpb25zaGlwIoIBCgxSZWxhdGlvbnNoaXASDgoGc3ltYm9sGAEgASgJEhQK",
            "DGlzX3JlZmVyZW5jZRgCIAEoCBIZChFpc19pbXBsZW1lbnRhdGlvbhgDIAEo",
            "CBIaChJpc190eXBlX2RlZmluaXRpb24YBCABKAgSFQoNaXNfZGVmaW5pdGlv",
            "bhgFIAEoCCKvAQoKT2NjdXJyZW5jZRINCgVyYW5nZRgBIAMoBRIOCgZzeW1i",
            "b2wYAiABKAkSFAoMc3ltYm9sX3JvbGVzGAMgASgFEh4KFm92ZXJyaWRlX2Rv",
            "Y3VtZW50YXRpb24YBCADKAkSJQoLc3ludGF4X2tpbmQYBSABKA4yEC5zY2lw",
            "LlN5bnRheEtpbmQSJQoLZGlhZ25vc3RpY3MYBiADKAsyEC5zY2lwLkRpYWdu",
            "b3N0aWMigAEKCkRpYWdub3N0aWMSIAoIc2V2ZXJpdHkYASABKA4yDi5zY2lw",
            "LlNldmVyaXR5EgwKBGNvZGUYAiABKAkSDwoHbWVzc2FnZRgDIAEoCRIOCgZz",
            "b3VyY2UYBCABKAkSIQoEdGFncxgFIAMoDjITLnNjaXAuRGlhZ25vc3RpY1Rh",
            "ZyoxCg9Qcm90b2NvbFZlcnNpb24SHgoaVW5zcGVjaWZpZWRQcm90b2NvbFZl",
            "cnNpb24QACpACgxUZXh0RW5jb2RpbmcSGwoXVW5zcGVjaWZpZWRUZXh0RW5j",
            "b2RpbmcQABIICgRVVEY4EAESCQoFVVRGMTYQAip9CgpTeW1ib2xSb2xlEhkK",
            "FVVuc3BlY2lmaWVkU3ltYm9sUm9sZRAAEg4KCkRlZmluaXRpb24QARIKCgZJ",
            "bXBvcnQQAhIPCgtXcml0ZUFjY2VzcxAEEg4KClJlYWRBY2Nlc3MQCBINCglH",
            "ZW5lcmF0ZWQQEBIICgRUZXN0ECAq6gYKClN5bnRheEtpbmQSGQoVVW5zcGVj",
            "aWZpZWRTeW50YXhLaW5kEAASCwoHQ29tbWVudBABEhgKFFB1bmN0dWF0aW9u",
            "RGVsaW1pdGVyEAISFgoSUHVuY3R1YXRpb25CcmFja2V0EAMSCwoHS2V5d29y",
            "ZBAEEhkKEUlkZW50aWZpZXJLZXl3b3JkEAQaAggBEhYKEklkZW50aWZpZXJP",
            "cGVyYXRvchAFEg4KCklkZW50aWZpZXIQBhIVChFJZGVudGlmaWVyQnVpbHRp",
            "bhAHEhIKDklkZW50aWZpZXJOdWxsEAgSFgoSSWRlbnRpZmllckNvbnN0YW50",
            "EAkSGwoXSWRlbnRpZmllck11dGFibGVHbG9iYWwQChIXChNJZGVudGlmaWVy",
            "UGFyYW1ldGVyEAsSEwoPSWRlbnRpZmllckxvY2FsEAwSFgoSSWRlbnRpZmll",
            "clNoYWRvd2VkEA0SFwoTSWRlbnRpZmllck5hbWVzcGFjZRAOEhgKEElkZW50",
            "aWZpZXJNb2R1bGUQDhoCCAESFgoSSWRlbnRpZmllckZ1bmN0aW9uEA8SIAoc",
            "SWRlbnRpZmllckZ1bmN0aW9uRGVmaW5pdGlvbhAQEhMKD0lkZW50aWZpZXJN",
            "YWNybxAREh0KGUlkZW50aWZpZXJNYWNyb0RlZmluaXRpb24QEhISCg5JZGVu",
            "dGlmaWVyVHlwZRATEhkKFUlkZW50aWZpZXJCdWlsdGluVHlwZRAUEhcKE0lk",
            "ZW50aWZpZXJBdHRyaWJ1dGUQFRIPCgtSZWdleEVzY2FwZRAWEhEKDVJlZ2V4",
            "UmVwZWF0ZWQQFxIRCg1SZWdleFdpbGRjYXJkEBgSEgoOUmVnZXhEZWxpbWl0",
            "ZXIQGRINCglSZWdleEpvaW4QGhIRCg1TdHJpbmdMaXRlcmFsEBsSFwoTU3Ry",
            "aW5nTGl0ZXJhbEVzY2FwZRAcEhgKFFN0cmluZ0xpdGVyYWxTcGVjaWFsEB0S",
            "FAoQU3RyaW5nTGl0ZXJhbEtleRAeEhQKEENoYXJhY3RlckxpdGVyYWwQHxIS",
            "Cg5OdW1lcmljTGl0ZXJhbBAgEhIKDkJvb2xlYW5MaXRlcmFsECESBwoDVGFn",
            "ECISEAoMVGFnQXR0cmlidXRlECMSEAoMVGFnRGVsaW1pdGVyECQaAhABKlYK",
            "CFNldmVyaXR5EhcKE1Vuc3BlY2lmaWVkU2V2ZXJpdHkQABIJCgVFcnJvchAB",
            "EgsKB1dhcm5pbmcQAhIPCgtJbmZvcm1hdGlvbhADEggKBEhpbnQQBCpOCg1E",
            "aWFnbm9zdGljVGFnEhwKGFVuc3BlY2lmaWVkRGlhZ25vc3RpY1RhZxAAEg8K",
            "C1VubmVjZXNzYXJ5EAESDgoKRGVwcmVjYXRlZBACKuAICghMYW5ndWFnZRIX",
            "ChNVbnNwZWNpZmllZExhbmd1YWdlEAASCAoEQUJBUBA8EgcKA0FQTBAxEgcK",
            "A0FkYRAnEggKBEFnZGEQLRIMCghBc2NpaURvYxBWEgwKCEFzc2VtYmx5EDoS",
            "BwoDQXdrEEISBwoDQmF0EEQSCgoGQmliVGVYEFESBQoBQxAiEgkKBUNPQk9M",
            "EDsSBwoDQ1BQECMSBwoDQ1NTEBoSCgoGQ1NoYXJwEAESCwoHQ2xvanVyZRAI",
            "EhAKDENvZmZlZXNjcmlwdBAVEg4KCkNvbW1vbkxpc3AQCRIHCgNDb3EQLxII",
            "CgREYXJ0EAMSCgoGRGVscGhpEDkSCAoERGlmZhBYEg4KCkRvY2tlcmZpbGUQ",
            "UBIKCgZEeWFsb2cQMhIKCgZFbGl4aXIQERIKCgZFcmxhbmcQEhIKCgZGU2hh",
            "cnAQKhIICgRGaXNoEEESCAoERmxvdxAYEgsKB0ZvcnRyYW4QOBIOCgpHaXRf",
            "Q29tbWl0EFsSDgoKR2l0X0NvbmZpZxBZEg4KCkdpdF9SZWJhc2UQXBIGCgJH",
            "bxAhEgoKBkdyb292eRAHEggKBEhUTUwQHhIICgRIYWNrEBQSDgoKSGFuZGxl",
            "YmFycxBaEgsKB0hhc2tlbGwQLBIJCgVJZHJpcxAuEgcKA0luaRBIEgUKAUoQ",
            "MxIICgRKU09OEEsSCAoESmF2YRAGEg4KCkphdmFTY3JpcHQQFhITCg9KYXZh",
            "U2NyaXB0UmVhY3QQXRILCgdKc29ubmV0EEwSCQoFSnVsaWEQNxIKCgZLb3Rs",
            "aW4QBBIJCgVMYVRlWBBTEggKBExlYW4QMBIICgRMZXNzEBsSBwoDTHVhEAwS",
            "DAoITWFrZWZpbGUQTxIMCghNYXJrZG93bhBUEgoKBk1hdGxhYhA0EgcKA05p",
            "eBBNEgkKBU9DYW1sECkSDwoLT2JqZWN0aXZlX0MQJBIRCg1PYmplY3RpdmVf",
            "Q1BQECUSBwoDUEhQEBMSCQoFUExTUUwQRhIICgRQZXJsEA0SDgoKUG93ZXJT",
            "aGVsbBBDEgoKBlByb2xvZxBHEgoKBlB5dGhvbhAPEgUKAVIQNhIKCgZSYWNr",
            "ZXQQCxIICgRSYWt1EA4SCQoFUmF6b3IQPhIICgRSZVNUEFUSCAoEUnVieRAQ",
            "EggKBFJ1c3QQKBIHCgNTQVMQPRIICgRTQ1NTEB0SBwoDU01MECsSBwoDU1FM",
            "EEUSCAoEU2FzcxAcEgkKBVNjYWxhEAUSCgoGU2NoZW1lEAoSDwoLU2hlbGxT",
            "Y3JpcHQQQBILCgdTa3lsYXJrEE4SCQoFU3dpZnQQAhIICgRUT01MEEkSBwoD",
            "VGVYEFISDgoKVHlwZVNjcmlwdBAXEhMKD1R5cGVTY3JpcHRSZWFjdBBeEg8K",
            "C1Zpc3VhbEJhc2ljED8SBwoDVnVlEBkSCwoHV29sZnJhbRA1EgcKA1hNTBAf",
            "EgcKA1hTTBAgEggKBFlBTUwQShIHCgNaaWcQJkIvWi1naXRodWIuY29tL3Nv",
            "dXJjZWdyYXBoL3NjaXAvYmluZGluZ3MvZ28vc2NpcC9iBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Scip.ProtocolVersion), typeof(global::Scip.TextEncoding), typeof(global::Scip.SymbolRole), typeof(global::Scip.SyntaxKind), typeof(global::Scip.Severity), typeof(global::Scip.DiagnosticTag), typeof(global::Scip.Language), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Scip.Index), global::Scip.Index.Parser, new[]{ "Metadata", "Documents", "ExternalSymbols" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scip.Metadata), global::Scip.Metadata.Parser, new[]{ "Version", "ToolInfo", "ProjectRoot", "TextDocumentEncoding" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scip.ToolInfo), global::Scip.ToolInfo.Parser, new[]{ "Name", "Version", "Arguments" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scip.Document), global::Scip.Document.Parser, new[]{ "Language", "RelativePath", "Occurrences", "Symbols" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scip.Symbol), global::Scip.Symbol.Parser, new[]{ "Scheme", "Package", "Descriptors" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scip.Package), global::Scip.Package.Parser, new[]{ "Manager", "Name", "Version" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scip.SymbolDescriptor), global::Scip.SymbolDescriptor.Parser, new[]{ "Name", "Disambiguator", "Suffix" }, null, new[]{ typeof(global::Scip.SymbolDescriptor.Types.Suffix) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scip.SymbolInformation), global::Scip.SymbolInformation.Parser, new[]{ "Symbol", "Documentation", "Relationships" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scip.Relationship), global::Scip.Relationship.Parser, new[]{ "Symbol", "IsReference", "IsImplementation", "IsTypeDefinition", "IsDefinition" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scip.Occurrence), global::Scip.Occurrence.Parser, new[]{ "Range", "Symbol", "SymbolRoles", "OverrideDocumentation", "SyntaxKind", "Diagnostics" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scip.Diagnostic), global::Scip.Diagnostic.Parser, new[]{ "Severity", "Code", "Message", "Source", "Tags" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  public enum ProtocolVersion {
    [pbr::OriginalName("UnspecifiedProtocolVersion")] UnspecifiedProtocolVersion = 0,
  }

  public enum TextEncoding {
    [pbr::OriginalName("UnspecifiedTextEncoding")] UnspecifiedTextEncoding = 0,
    [pbr::OriginalName("UTF8")] Utf8 = 1,
    [pbr::OriginalName("UTF16")] Utf16 = 2,
  }

  /// <summary>
  /// SymbolRole declares what "role" a symbol has in an occurrence.  A role is
  /// encoded as a bitset where each bit represents a different role. For example,
  /// to determine if the `Import` role is set, test whether the second bit of the
  /// enum value is defined. In pseudocode, this can be implemented with the
  /// logic: `const isImportRole = (role.value &amp; SymbolRole.Import.value) > 0`.
  /// </summary>
  public enum SymbolRole {
    /// <summary>
    /// This case is not meant to be used; it only exists to avoid an error
    /// from the Protobuf code generator.
    /// </summary>
    [pbr::OriginalName("UnspecifiedSymbolRole")] UnspecifiedSymbolRole = 0,
    /// <summary>
    /// Is the symbol defined here? If not, then this is a symbol reference.
    /// </summary>
    [pbr::OriginalName("Definition")] Definition = 1,
    /// <summary>
    /// Is the symbol imported here?
    /// </summary>
    [pbr::OriginalName("Import")] Import = 2,
    /// <summary>
    /// Is the symbol written here?
    /// </summary>
    [pbr::OriginalName("WriteAccess")] WriteAccess = 4,
    /// <summary>
    /// Is the symbol read here?
    /// </summary>
    [pbr::OriginalName("ReadAccess")] ReadAccess = 8,
    /// <summary>
    /// Is the symbol in generated code?
    /// </summary>
    [pbr::OriginalName("Generated")] Generated = 16,
    /// <summary>
    /// Is the symbol in test code?
    /// </summary>
    [pbr::OriginalName("Test")] Test = 32,
  }

  public enum SyntaxKind {
    [pbr::OriginalName("UnspecifiedSyntaxKind")] UnspecifiedSyntaxKind = 0,
    /// <summary>
    /// Comment, including comment markers and text
    /// </summary>
    [pbr::OriginalName("Comment")] Comment = 1,
    /// <summary>
    /// `;` `.` `,`
    /// </summary>
    [pbr::OriginalName("PunctuationDelimiter")] PunctuationDelimiter = 2,
    /// <summary>
    /// (), {}, [] when used syntactically
    /// </summary>
    [pbr::OriginalName("PunctuationBracket")] PunctuationBracket = 3,
    /// <summary>
    /// `if`, `else`, `return`, `class`, etc.
    /// </summary>
    [pbr::OriginalName("Keyword")] Keyword = 4,
    [pbr::OriginalName("IdentifierKeyword", PreferredAlias = false)] IdentifierKeyword = 4,
    /// <summary>
    /// `+`, `*`, etc.
    /// </summary>
    [pbr::OriginalName("IdentifierOperator")] IdentifierOperator = 5,
    /// <summary>
    /// non-specific catch-all for any identifier not better described elsewhere
    /// </summary>
    [pbr::OriginalName("Identifier")] Identifier = 6,
    /// <summary>
    /// Identifiers builtin to the language: `min`, `print` in Python.
    /// </summary>
    [pbr::OriginalName("IdentifierBuiltin")] IdentifierBuiltin = 7,
    /// <summary>
    /// Identifiers representing `null`-like values: `None` in Python, `nil` in Go.
    /// </summary>
    [pbr::OriginalName("IdentifierNull")] IdentifierNull = 8,
    /// <summary>
    /// `xyz` in `const xyz = "hello"`
    /// </summary>
    [pbr::OriginalName("IdentifierConstant")] IdentifierConstant = 9,
    /// <summary>
    /// `var X = "hello"` in Go
    /// </summary>
    [pbr::OriginalName("IdentifierMutableGlobal")] IdentifierMutableGlobal = 10,
    /// <summary>
    /// Parameter definition and references
    /// </summary>
    [pbr::OriginalName("IdentifierParameter")] IdentifierParameter = 11,
    /// <summary>
    /// Identifiers for variable definitions and references within a local scope
    /// </summary>
    [pbr::OriginalName("IdentifierLocal")] IdentifierLocal = 12,
    /// <summary>
    /// Identifiers that shadow other identifiers in an outer scope
    /// </summary>
    [pbr::OriginalName("IdentifierShadowed")] IdentifierShadowed = 13,
    /// <summary>
    /// Identifier representing a unit of code abstraction and/or namespacing.
    ///
    /// NOTE: This corresponds to a package in Go and JVM languages,
    /// and a module in languages like Python and JavaScript.
    /// </summary>
    [pbr::OriginalName("IdentifierNamespace")] IdentifierNamespace = 14,
    [pbr::OriginalName("IdentifierModule", PreferredAlias = false)] IdentifierModule = 14,
    /// <summary>
    /// Function references, including calls
    /// </summary>
    [pbr::OriginalName("IdentifierFunction")] IdentifierFunction = 15,
    /// <summary>
    /// Function definition only
    /// </summary>
    [pbr::OriginalName("IdentifierFunctionDefinition")] IdentifierFunctionDefinition = 16,
    /// <summary>
    /// Macro references, including invocations
    /// </summary>
    [pbr::OriginalName("IdentifierMacro")] IdentifierMacro = 17,
    /// <summary>
    /// Macro definition only
    /// </summary>
    [pbr::OriginalName("IdentifierMacroDefinition")] IdentifierMacroDefinition = 18,
    /// <summary>
    /// non-builtin types
    /// </summary>
    [pbr::OriginalName("IdentifierType")] IdentifierType = 19,
    /// <summary>
    /// builtin types only, such as `str` for Python or `int` in Go
    /// </summary>
    [pbr::OriginalName("IdentifierBuiltinType")] IdentifierBuiltinType = 20,
    /// <summary>
    /// Python decorators, c-like __attribute__
    /// </summary>
    [pbr::OriginalName("IdentifierAttribute")] IdentifierAttribute = 21,
    /// <summary>
    /// `\b`
    /// </summary>
    [pbr::OriginalName("RegexEscape")] RegexEscape = 22,
    /// <summary>
    /// `*`, `+`
    /// </summary>
    [pbr::OriginalName("RegexRepeated")] RegexRepeated = 23,
    /// <summary>
    /// `.`
    /// </summary>
    [pbr::OriginalName("RegexWildcard")] RegexWildcard = 24,
    /// <summary>
    /// `(`, `)`, `[`, `]`
    /// </summary>
    [pbr::OriginalName("RegexDelimiter")] RegexDelimiter = 25,
    /// <summary>
    /// `|`, `-`
    /// </summary>
    [pbr::OriginalName("RegexJoin")] RegexJoin = 26,
    /// <summary>
    /// Literal strings: "Hello, world!"
    /// </summary>
    [pbr::OriginalName("StringLiteral")] StringLiteral = 27,
    /// <summary>
    /// non-regex escapes: "\t", "\n"
    /// </summary>
    [pbr::OriginalName("StringLiteralEscape")] StringLiteralEscape = 28,
    /// <summary>
    /// datetimes within strings, special words within a string, `{}` in format strings
    /// </summary>
    [pbr::OriginalName("StringLiteralSpecial")] StringLiteralSpecial = 29,
    /// <summary>
    /// "key" in { "key": "value" }, useful for example in JSON
    /// </summary>
    [pbr::OriginalName("StringLiteralKey")] StringLiteralKey = 30,
    /// <summary>
    /// 'c' or similar, in languages that differentiate strings and characters
    /// </summary>
    [pbr::OriginalName("CharacterLiteral")] CharacterLiteral = 31,
    /// <summary>
    /// Literal numbers, both floats and integers
    /// </summary>
    [pbr::OriginalName("NumericLiteral")] NumericLiteral = 32,
    /// <summary>
    /// `true`, `false`
    /// </summary>
    [pbr::OriginalName("BooleanLiteral")] BooleanLiteral = 33,
    /// <summary>
    /// Used for XML-like tags
    /// </summary>
    [pbr::OriginalName("Tag")] Tag = 34,
    /// <summary>
    /// Attribute name in XML-like tags
    /// </summary>
    [pbr::OriginalName("TagAttribute")] TagAttribute = 35,
    /// <summary>
    /// Delimiters for XML-like tags
    /// </summary>
    [pbr::OriginalName("TagDelimiter")] TagDelimiter = 36,
  }

  public enum Severity {
    [pbr::OriginalName("UnspecifiedSeverity")] UnspecifiedSeverity = 0,
    [pbr::OriginalName("Error")] Error = 1,
    [pbr::OriginalName("Warning")] Warning = 2,
    [pbr::OriginalName("Information")] Information = 3,
    [pbr::OriginalName("Hint")] Hint = 4,
  }

  public enum DiagnosticTag {
    [pbr::OriginalName("UnspecifiedDiagnosticTag")] UnspecifiedDiagnosticTag = 0,
    [pbr::OriginalName("Unnecessary")] Unnecessary = 1,
    [pbr::OriginalName("Deprecated")] Deprecated = 2,
  }

  /// <summary>
  /// Language standardises names of common programming languages that can be used
  /// for the `Document.language` field. The primary purpose of this enum is to
  /// prevent a situation where we have a single programming language ends up with
  /// multiple string representations. For example, the C++ language uses the name
  /// "CPlusPlus" in this enum and other names such as "cpp" are incompatible.
  /// Feel free to send a pull-request to add missing programming languages.
  /// </summary>
  public enum Language {
    [pbr::OriginalName("UnspecifiedLanguage")] UnspecifiedLanguage = 0,
    [pbr::OriginalName("ABAP")] Abap = 60,
    [pbr::OriginalName("APL")] Apl = 49,
    [pbr::OriginalName("Ada")] Ada = 39,
    [pbr::OriginalName("Agda")] Agda = 45,
    [pbr::OriginalName("AsciiDoc")] AsciiDoc = 86,
    [pbr::OriginalName("Assembly")] Assembly = 58,
    [pbr::OriginalName("Awk")] Awk = 66,
    [pbr::OriginalName("Bat")] Bat = 68,
    [pbr::OriginalName("BibTeX")] BibTeX = 81,
    [pbr::OriginalName("C")] C = 34,
    [pbr::OriginalName("COBOL")] Cobol = 59,
    /// <summary>
    /// C++ (the name "CPP" was chosen for consistency with LSP)
    /// </summary>
    [pbr::OriginalName("CPP")] Cpp = 35,
    [pbr::OriginalName("CSS")] Css = 26,
    [pbr::OriginalName("CSharp")] Csharp = 1,
    [pbr::OriginalName("Clojure")] Clojure = 8,
    [pbr::OriginalName("Coffeescript")] Coffeescript = 21,
    [pbr::OriginalName("CommonLisp")] CommonLisp = 9,
    [pbr::OriginalName("Coq")] Coq = 47,
    [pbr::OriginalName("Dart")] Dart = 3,
    [pbr::OriginalName("Delphi")] Delphi = 57,
    [pbr::OriginalName("Diff")] Diff = 88,
    [pbr::OriginalName("Dockerfile")] Dockerfile = 80,
    [pbr::OriginalName("Dyalog")] Dyalog = 50,
    [pbr::OriginalName("Elixir")] Elixir = 17,
    [pbr::OriginalName("Erlang")] Erlang = 18,
    [pbr::OriginalName("FSharp")] Fsharp = 42,
    [pbr::OriginalName("Fish")] Fish = 65,
    [pbr::OriginalName("Flow")] Flow = 24,
    [pbr::OriginalName("Fortran")] Fortran = 56,
    [pbr::OriginalName("Git_Commit")] GitCommit = 91,
    [pbr::OriginalName("Git_Config")] GitConfig = 89,
    [pbr::OriginalName("Git_Rebase")] GitRebase = 92,
    [pbr::OriginalName("Go")] Go = 33,
    [pbr::OriginalName("Groovy")] Groovy = 7,
    [pbr::OriginalName("HTML")] Html = 30,
    [pbr::OriginalName("Hack")] Hack = 20,
    [pbr::OriginalName("Handlebars")] Handlebars = 90,
    [pbr::OriginalName("Haskell")] Haskell = 44,
    [pbr::OriginalName("Idris")] Idris = 46,
    [pbr::OriginalName("Ini")] Ini = 72,
    [pbr::OriginalName("J")] J = 51,
    [pbr::OriginalName("JSON")] Json = 75,
    [pbr::OriginalName("Java")] Java = 6,
    [pbr::OriginalName("JavaScript")] JavaScript = 22,
    [pbr::OriginalName("JavaScriptReact")] JavaScriptReact = 93,
    [pbr::OriginalName("Jsonnet")] Jsonnet = 76,
    [pbr::OriginalName("Julia")] Julia = 55,
    [pbr::OriginalName("Kotlin")] Kotlin = 4,
    [pbr::OriginalName("LaTeX")] LaTeX = 83,
    [pbr::OriginalName("Lean")] Lean = 48,
    [pbr::OriginalName("Less")] Less = 27,
    [pbr::OriginalName("Lua")] Lua = 12,
    [pbr::OriginalName("Makefile")] Makefile = 79,
    [pbr::OriginalName("Markdown")] Markdown = 84,
    [pbr::OriginalName("Matlab")] Matlab = 52,
    [pbr::OriginalName("Nix")] Nix = 77,
    [pbr::OriginalName("OCaml")] Ocaml = 41,
    [pbr::OriginalName("Objective_C")] ObjectiveC = 36,
    [pbr::OriginalName("Objective_CPP")] ObjectiveCpp = 37,
    [pbr::OriginalName("PHP")] Php = 19,
    [pbr::OriginalName("PLSQL")] Plsql = 70,
    [pbr::OriginalName("Perl")] Perl = 13,
    [pbr::OriginalName("PowerShell")] PowerShell = 67,
    [pbr::OriginalName("Prolog")] Prolog = 71,
    [pbr::OriginalName("Python")] Python = 15,
    [pbr::OriginalName("R")] R = 54,
    [pbr::OriginalName("Racket")] Racket = 11,
    [pbr::OriginalName("Raku")] Raku = 14,
    [pbr::OriginalName("Razor")] Razor = 62,
    [pbr::OriginalName("ReST")] ReSt = 85,
    [pbr::OriginalName("Ruby")] Ruby = 16,
    [pbr::OriginalName("Rust")] Rust = 40,
    [pbr::OriginalName("SAS")] Sas = 61,
    [pbr::OriginalName("SCSS")] Scss = 29,
    [pbr::OriginalName("SML")] Sml = 43,
    [pbr::OriginalName("SQL")] Sql = 69,
    [pbr::OriginalName("Sass")] Sass = 28,
    [pbr::OriginalName("Scala")] Scala = 5,
    [pbr::OriginalName("Scheme")] Scheme = 10,
    /// <summary>
    /// Bash
    /// </summary>
    [pbr::OriginalName("ShellScript")] ShellScript = 64,
    [pbr::OriginalName("Skylark")] Skylark = 78,
    [pbr::OriginalName("Swift")] Swift = 2,
    [pbr::OriginalName("TOML")] Toml = 73,
    [pbr::OriginalName("TeX")] TeX = 82,
    [pbr::OriginalName("TypeScript")] TypeScript = 23,
    [pbr::OriginalName("TypeScriptReact")] TypeScriptReact = 94,
    [pbr::OriginalName("VisualBasic")] VisualBasic = 63,
    [pbr::OriginalName("Vue")] Vue = 25,
    [pbr::OriginalName("Wolfram")] Wolfram = 53,
    [pbr::OriginalName("XML")] Xml = 31,
    [pbr::OriginalName("XSL")] Xsl = 32,
    [pbr::OriginalName("YAML")] Yaml = 74,
    /// <summary>
    /// NextLanguage = 95;
    /// Steps add a new language:
    /// 1. Copy-paste the "NextLanguage = N" line above
    /// 2. Increment "NextLanguage = N" to "NextLanguage = N+1"
    /// 3. Replace "NextLanguage = N" with the name of the new language.
    /// 4. Move the new language to the correct line above using alphabetical order
    /// 5. (optional) Add a brief comment behind the language if the name is not self-explanatory
    /// </summary>
    [pbr::OriginalName("Zig")] Zig = 38,
  }

  #endregion

  #region Messages
  /// <summary>
  /// Index represents a complete SCIP index for a workspace this is rooted at a
  /// single directory. An Index message payload can have a large memory footprint
  /// and it's therefore recommended to emit and consume an Index payload one field
  /// value at a time. To permit streaming consumption of an Index payload, the
  /// `metadata` field must appear at the start of the stream and must only appear
  /// once in the stream. Other field values may appear in any order.
  /// </summary>
  public sealed partial class Index : pb::IMessage<Index>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Index> _parser = new pb::MessageParser<Index>(() => new Index());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Index> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scip.ScipReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Index() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Index(Index other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      documents_ = other.documents_.Clone();
      externalSymbols_ = other.externalSymbols_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Index Clone() {
      return new Index(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::Scip.Metadata metadata_;
    /// <summary>
    /// Metadata about this index.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Scip.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "documents" field.</summary>
    public const int DocumentsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Scip.Document> _repeated_documents_codec
        = pb::FieldCodec.ForMessage(18, global::Scip.Document.Parser);
    private readonly pbc::RepeatedField<global::Scip.Document> documents_ = new pbc::RepeatedField<global::Scip.Document>();
    /// <summary>
    /// Documents that belong to this index.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Scip.Document> Documents {
      get { return documents_; }
    }

    /// <summary>Field number for the "external_symbols" field.</summary>
    public const int ExternalSymbolsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Scip.SymbolInformation> _repeated_externalSymbols_codec
        = pb::FieldCodec.ForMessage(26, global::Scip.SymbolInformation.Parser);
    private readonly pbc::RepeatedField<global::Scip.SymbolInformation> externalSymbols_ = new pbc::RepeatedField<global::Scip.SymbolInformation>();
    /// <summary>
    /// (optional) Symbols that are referenced from this index but are defined in
    /// an external package (a separate `Index` message). Leave this field empty
    /// if you assume the external package will get indexed separately. If the
    /// external package won't get indexed for some reason then you can use this
    /// field to provide hover documentation for those external symbols.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Scip.SymbolInformation> ExternalSymbols {
      get { return externalSymbols_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Index);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Index other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!documents_.Equals(other.documents_)) return false;
      if(!externalSymbols_.Equals(other.externalSymbols_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= documents_.GetHashCode();
      hash ^= externalSymbols_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      documents_.WriteTo(output, _repeated_documents_codec);
      externalSymbols_.WriteTo(output, _repeated_externalSymbols_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      documents_.WriteTo(ref output, _repeated_documents_codec);
      externalSymbols_.WriteTo(ref output, _repeated_externalSymbols_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += documents_.CalculateSize(_repeated_documents_codec);
      size += externalSymbols_.CalculateSize(_repeated_externalSymbols_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Index other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::Scip.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      documents_.Add(other.documents_);
      externalSymbols_.Add(other.externalSymbols_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::Scip.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            documents_.AddEntriesFrom(input, _repeated_documents_codec);
            break;
          }
          case 26: {
            externalSymbols_.AddEntriesFrom(input, _repeated_externalSymbols_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::Scip.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            documents_.AddEntriesFrom(ref input, _repeated_documents_codec);
            break;
          }
          case 26: {
            externalSymbols_.AddEntriesFrom(ref input, _repeated_externalSymbols_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class Metadata : pb::IMessage<Metadata>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Metadata> _parser = new pb::MessageParser<Metadata>(() => new Metadata());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Metadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scip.ScipReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Metadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Metadata(Metadata other) : this() {
      version_ = other.version_;
      toolInfo_ = other.toolInfo_ != null ? other.toolInfo_.Clone() : null;
      projectRoot_ = other.projectRoot_;
      textDocumentEncoding_ = other.textDocumentEncoding_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Metadata Clone() {
      return new Metadata(this);
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 1;
    private global::Scip.ProtocolVersion version_ = global::Scip.ProtocolVersion.UnspecifiedProtocolVersion;
    /// <summary>
    /// Which version of this protocol was used to generate this index?
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Scip.ProtocolVersion Version {
      get { return version_; }
      set {
        version_ = value;
      }
    }

    /// <summary>Field number for the "tool_info" field.</summary>
    public const int ToolInfoFieldNumber = 2;
    private global::Scip.ToolInfo toolInfo_;
    /// <summary>
    /// Information about the tool that produced this index.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Scip.ToolInfo ToolInfo {
      get { return toolInfo_; }
      set {
        toolInfo_ = value;
      }
    }

    /// <summary>Field number for the "project_root" field.</summary>
    public const int ProjectRootFieldNumber = 3;
    private string projectRoot_ = "";
    /// <summary>
    /// URI-encoded absolute path to the root directory of this index. All
    /// documents in this index must appear in a subdirectory of this root
    /// directory.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ProjectRoot {
      get { return projectRoot_; }
      set {
        projectRoot_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "text_document_encoding" field.</summary>
    public const int TextDocumentEncodingFieldNumber = 4;
    private global::Scip.TextEncoding textDocumentEncoding_ = global::Scip.TextEncoding.UnspecifiedTextEncoding;
    /// <summary>
    /// Text encoding of the source files on disk that are referenced from
    /// `Document.relative_path`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Scip.TextEncoding TextDocumentEncoding {
      get { return textDocumentEncoding_; }
      set {
        textDocumentEncoding_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Metadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Metadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Version != other.Version) return false;
      if (!object.Equals(ToolInfo, other.ToolInfo)) return false;
      if (ProjectRoot != other.ProjectRoot) return false;
      if (TextDocumentEncoding != other.TextDocumentEncoding) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Version != global::Scip.ProtocolVersion.UnspecifiedProtocolVersion) hash ^= Version.GetHashCode();
      if (toolInfo_ != null) hash ^= ToolInfo.GetHashCode();
      if (ProjectRoot.Length != 0) hash ^= ProjectRoot.GetHashCode();
      if (TextDocumentEncoding != global::Scip.TextEncoding.UnspecifiedTextEncoding) hash ^= TextDocumentEncoding.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Version != global::Scip.ProtocolVersion.UnspecifiedProtocolVersion) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Version);
      }
      if (toolInfo_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ToolInfo);
      }
      if (ProjectRoot.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(ProjectRoot);
      }
      if (TextDocumentEncoding != global::Scip.TextEncoding.UnspecifiedTextEncoding) {
        output.WriteRawTag(32);
        output.WriteEnum((int) TextDocumentEncoding);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Version != global::Scip.ProtocolVersion.UnspecifiedProtocolVersion) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Version);
      }
      if (toolInfo_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ToolInfo);
      }
      if (ProjectRoot.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(ProjectRoot);
      }
      if (TextDocumentEncoding != global::Scip.TextEncoding.UnspecifiedTextEncoding) {
        output.WriteRawTag(32);
        output.WriteEnum((int) TextDocumentEncoding);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Version != global::Scip.ProtocolVersion.UnspecifiedProtocolVersion) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Version);
      }
      if (toolInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ToolInfo);
      }
      if (ProjectRoot.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProjectRoot);
      }
      if (TextDocumentEncoding != global::Scip.TextEncoding.UnspecifiedTextEncoding) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TextDocumentEncoding);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Metadata other) {
      if (other == null) {
        return;
      }
      if (other.Version != global::Scip.ProtocolVersion.UnspecifiedProtocolVersion) {
        Version = other.Version;
      }
      if (other.toolInfo_ != null) {
        if (toolInfo_ == null) {
          ToolInfo = new global::Scip.ToolInfo();
        }
        ToolInfo.MergeFrom(other.ToolInfo);
      }
      if (other.ProjectRoot.Length != 0) {
        ProjectRoot = other.ProjectRoot;
      }
      if (other.TextDocumentEncoding != global::Scip.TextEncoding.UnspecifiedTextEncoding) {
        TextDocumentEncoding = other.TextDocumentEncoding;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Version = (global::Scip.ProtocolVersion) input.ReadEnum();
            break;
          }
          case 18: {
            if (toolInfo_ == null) {
              ToolInfo = new global::Scip.ToolInfo();
            }
            input.ReadMessage(ToolInfo);
            break;
          }
          case 26: {
            ProjectRoot = input.ReadString();
            break;
          }
          case 32: {
            TextDocumentEncoding = (global::Scip.TextEncoding) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Version = (global::Scip.ProtocolVersion) input.ReadEnum();
            break;
          }
          case 18: {
            if (toolInfo_ == null) {
              ToolInfo = new global::Scip.ToolInfo();
            }
            input.ReadMessage(ToolInfo);
            break;
          }
          case 26: {
            ProjectRoot = input.ReadString();
            break;
          }
          case 32: {
            TextDocumentEncoding = (global::Scip.TextEncoding) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class ToolInfo : pb::IMessage<ToolInfo>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ToolInfo> _parser = new pb::MessageParser<ToolInfo>(() => new ToolInfo());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ToolInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scip.ScipReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ToolInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ToolInfo(ToolInfo other) : this() {
      name_ = other.name_;
      version_ = other.version_;
      arguments_ = other.arguments_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ToolInfo Clone() {
      return new ToolInfo(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Name of the indexer that produced this index.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 2;
    private string version_ = "";
    /// <summary>
    /// Version of the indexer that produced this index.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Version {
      get { return version_; }
      set {
        version_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "arguments" field.</summary>
    public const int ArgumentsFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_arguments_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> arguments_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Command-line arguments that were used to invoke this indexer.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Arguments {
      get { return arguments_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ToolInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ToolInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Version != other.Version) return false;
      if(!arguments_.Equals(other.arguments_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Version.Length != 0) hash ^= Version.GetHashCode();
      hash ^= arguments_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Version.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Version);
      }
      arguments_.WriteTo(output, _repeated_arguments_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Version.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Version);
      }
      arguments_.WriteTo(ref output, _repeated_arguments_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Version.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Version);
      }
      size += arguments_.CalculateSize(_repeated_arguments_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ToolInfo other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Version.Length != 0) {
        Version = other.Version;
      }
      arguments_.Add(other.arguments_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Version = input.ReadString();
            break;
          }
          case 26: {
            arguments_.AddEntriesFrom(input, _repeated_arguments_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Version = input.ReadString();
            break;
          }
          case 26: {
            arguments_.AddEntriesFrom(ref input, _repeated_arguments_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Document defines the metadata about a source file on disk.
  /// </summary>
  public sealed partial class Document : pb::IMessage<Document>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Document> _parser = new pb::MessageParser<Document>(() => new Document());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Document> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scip.ScipReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Document() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Document(Document other) : this() {
      language_ = other.language_;
      relativePath_ = other.relativePath_;
      occurrences_ = other.occurrences_.Clone();
      symbols_ = other.symbols_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Document Clone() {
      return new Document(this);
    }

    /// <summary>Field number for the "language" field.</summary>
    public const int LanguageFieldNumber = 4;
    private string language_ = "";
    /// <summary>
    /// The string ID for the programming language this file is written in.
    /// The `Language` enum contains the names of most common programming languages.
    /// This field is typed as a string to permit any programming langauge, including
    /// ones that are not specified by the `Language` enum.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Language {
      get { return language_; }
      set {
        language_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "relative_path" field.</summary>
    public const int RelativePathFieldNumber = 1;
    private string relativePath_ = "";
    /// <summary>
    /// (Required) Unique path to the text document.
    ///
    /// 1. The path must be relative to the directory supplied in the associated
    ///    `Metadata.project_root`.
    /// 2. The path must not begin with a leading '/'.
    /// 3. The path must point to a regular file, not a symbolic link.
    /// 4. The path must use '/' as the separator, including on Windows.
    /// 5. The path must be canonical; it cannot include empty components ('//'),
    ///    or '.' or '..'.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RelativePath {
      get { return relativePath_; }
      set {
        relativePath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "occurrences" field.</summary>
    public const int OccurrencesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Scip.Occurrence> _repeated_occurrences_codec
        = pb::FieldCodec.ForMessage(18, global::Scip.Occurrence.Parser);
    private readonly pbc::RepeatedField<global::Scip.Occurrence> occurrences_ = new pbc::RepeatedField<global::Scip.Occurrence>();
    /// <summary>
    /// Occurrences that appear in this file.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Scip.Occurrence> Occurrences {
      get { return occurrences_; }
    }

    /// <summary>Field number for the "symbols" field.</summary>
    public const int SymbolsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Scip.SymbolInformation> _repeated_symbols_codec
        = pb::FieldCodec.ForMessage(26, global::Scip.SymbolInformation.Parser);
    private readonly pbc::RepeatedField<global::Scip.SymbolInformation> symbols_ = new pbc::RepeatedField<global::Scip.SymbolInformation>();
    /// <summary>
    /// Symbols that are "defined" within this document.
    ///
    /// This should include symbols which technically do not have any definition,
    /// but have a reference and are defined by some other symbol (see
    /// Relationship.is_definition).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Scip.SymbolInformation> Symbols {
      get { return symbols_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Document);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Document other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Language != other.Language) return false;
      if (RelativePath != other.RelativePath) return false;
      if(!occurrences_.Equals(other.occurrences_)) return false;
      if(!symbols_.Equals(other.symbols_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Language.Length != 0) hash ^= Language.GetHashCode();
      if (RelativePath.Length != 0) hash ^= RelativePath.GetHashCode();
      hash ^= occurrences_.GetHashCode();
      hash ^= symbols_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (RelativePath.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(RelativePath);
      }
      occurrences_.WriteTo(output, _repeated_occurrences_codec);
      symbols_.WriteTo(output, _repeated_symbols_codec);
      if (Language.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Language);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (RelativePath.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(RelativePath);
      }
      occurrences_.WriteTo(ref output, _repeated_occurrences_codec);
      symbols_.WriteTo(ref output, _repeated_symbols_codec);
      if (Language.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Language);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Language.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Language);
      }
      if (RelativePath.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RelativePath);
      }
      size += occurrences_.CalculateSize(_repeated_occurrences_codec);
      size += symbols_.CalculateSize(_repeated_symbols_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Document other) {
      if (other == null) {
        return;
      }
      if (other.Language.Length != 0) {
        Language = other.Language;
      }
      if (other.RelativePath.Length != 0) {
        RelativePath = other.RelativePath;
      }
      occurrences_.Add(other.occurrences_);
      symbols_.Add(other.symbols_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            RelativePath = input.ReadString();
            break;
          }
          case 18: {
            occurrences_.AddEntriesFrom(input, _repeated_occurrences_codec);
            break;
          }
          case 26: {
            symbols_.AddEntriesFrom(input, _repeated_symbols_codec);
            break;
          }
          case 34: {
            Language = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            RelativePath = input.ReadString();
            break;
          }
          case 18: {
            occurrences_.AddEntriesFrom(ref input, _repeated_occurrences_codec);
            break;
          }
          case 26: {
            symbols_.AddEntriesFrom(ref input, _repeated_symbols_codec);
            break;
          }
          case 34: {
            Language = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Symbol is similar to a URI, it identifies a class, method, or a local
  /// variable. `SymbolInformation` contains rich metadata about symbols such as
  /// the docstring.
  ///
  /// Symbol has a standardized string representation, which can be used
  /// interchangeably with `Symbol`. The syntax for Symbol is the following:
  /// ```
  /// # (&lt;x>)+ stands for one or more repetitions of &lt;x>
  /// &lt;symbol>               ::= &lt;scheme> ' ' &lt;package> ' ' (&lt;descriptor>)+ | 'local ' &lt;local-id>
  /// &lt;package>              ::= &lt;manager> ' ' &lt;package-name> ' ' &lt;version>
  /// &lt;scheme>               ::= any UTF-8, escape spaces with double space.
  /// &lt;manager>              ::= same as above, use the placeholder '.' to indicate an empty value
  /// &lt;package-name>         ::= same as above
  /// &lt;version>              ::= same as above
  /// &lt;descriptor>           ::= &lt;namespace> | &lt;type> | &lt;term> | &lt;method> | &lt;type-parameter> | &lt;parameter> | &lt;meta>
  /// &lt;namespace>            ::= &lt;name> '/'
  /// &lt;type>                 ::= &lt;name> '#'
  /// &lt;term>                 ::= &lt;name> '.'
  /// &lt;meta>                 ::= &lt;name> ':'
  /// &lt;method>               ::= &lt;name> '(' &lt;method-disambiguator> ').'
  /// &lt;type-parameter>       ::= '[' &lt;name> ']'
  /// &lt;parameter>            ::= '(' &lt;name> ')'
  /// &lt;name>                 ::= &lt;identifier>
  /// &lt;method-disambiguator> ::= &lt;simple-identifier>
  /// &lt;identifier>           ::= &lt;simple-identifier> | &lt;escaped-identifier>
  /// &lt;simple-identifier>    ::= (&lt;identifier-character>)+
  /// &lt;identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit
  /// &lt;escaped-identifier>   ::= '`' (&lt;escaped-character>)+ '`'
  /// &lt;escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.
  /// ```
  ///
  /// The list of descriptors for a symbol should together form a fully
  /// qualified name for the symbol. That is, it should serve as a unique
  /// identifier across the package. Typically, it will include one descriptor
  /// for every node in the AST (along the ancestry path) between the root of
  /// the file and the node corresponding to the symbol.
  /// </summary>
  public sealed partial class Symbol : pb::IMessage<Symbol>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Symbol> _parser = new pb::MessageParser<Symbol>(() => new Symbol());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Symbol> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scip.ScipReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Symbol() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Symbol(Symbol other) : this() {
      scheme_ = other.scheme_;
      package_ = other.package_ != null ? other.package_.Clone() : null;
      descriptors_ = other.descriptors_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Symbol Clone() {
      return new Symbol(this);
    }

    /// <summary>Field number for the "scheme" field.</summary>
    public const int SchemeFieldNumber = 1;
    private string scheme_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Scheme {
      get { return scheme_; }
      set {
        scheme_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "package" field.</summary>
    public const int PackageFieldNumber = 2;
    private global::Scip.Package package_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Scip.Package Package {
      get { return package_; }
      set {
        package_ = value;
      }
    }

    /// <summary>Field number for the "descriptors" field.</summary>
    public const int DescriptorsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Scip.SymbolDescriptor> _repeated_descriptors_codec
        = pb::FieldCodec.ForMessage(26, global::Scip.SymbolDescriptor.Parser);
    private readonly pbc::RepeatedField<global::Scip.SymbolDescriptor> descriptors_ = new pbc::RepeatedField<global::Scip.SymbolDescriptor>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Scip.SymbolDescriptor> Descriptors {
      get { return descriptors_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Symbol);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Symbol other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Scheme != other.Scheme) return false;
      if (!object.Equals(Package, other.Package)) return false;
      if(!descriptors_.Equals(other.descriptors_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Scheme.Length != 0) hash ^= Scheme.GetHashCode();
      if (package_ != null) hash ^= Package.GetHashCode();
      hash ^= descriptors_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Scheme.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Scheme);
      }
      if (package_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Package);
      }
      descriptors_.WriteTo(output, _repeated_descriptors_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Scheme.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Scheme);
      }
      if (package_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Package);
      }
      descriptors_.WriteTo(ref output, _repeated_descriptors_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Scheme.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Scheme);
      }
      if (package_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Package);
      }
      size += descriptors_.CalculateSize(_repeated_descriptors_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Symbol other) {
      if (other == null) {
        return;
      }
      if (other.Scheme.Length != 0) {
        Scheme = other.Scheme;
      }
      if (other.package_ != null) {
        if (package_ == null) {
          Package = new global::Scip.Package();
        }
        Package.MergeFrom(other.Package);
      }
      descriptors_.Add(other.descriptors_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Scheme = input.ReadString();
            break;
          }
          case 18: {
            if (package_ == null) {
              Package = new global::Scip.Package();
            }
            input.ReadMessage(Package);
            break;
          }
          case 26: {
            descriptors_.AddEntriesFrom(input, _repeated_descriptors_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Scheme = input.ReadString();
            break;
          }
          case 18: {
            if (package_ == null) {
              Package = new global::Scip.Package();
            }
            input.ReadMessage(Package);
            break;
          }
          case 26: {
            descriptors_.AddEntriesFrom(ref input, _repeated_descriptors_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Unit of packaging and distribution.
  ///
  /// NOTE: This corresponds to a module in Go and JVM languages.
  /// </summary>
  public sealed partial class Package : pb::IMessage<Package>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Package> _parser = new pb::MessageParser<Package>(() => new Package());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Package> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scip.ScipReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Package() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Package(Package other) : this() {
      manager_ = other.manager_;
      name_ = other.name_;
      version_ = other.version_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Package Clone() {
      return new Package(this);
    }

    /// <summary>Field number for the "manager" field.</summary>
    public const int ManagerFieldNumber = 1;
    private string manager_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Manager {
      get { return manager_; }
      set {
        manager_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 2;
    private string name_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 3;
    private string version_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Version {
      get { return version_; }
      set {
        version_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Package);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Package other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Manager != other.Manager) return false;
      if (Name != other.Name) return false;
      if (Version != other.Version) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Manager.Length != 0) hash ^= Manager.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Version.Length != 0) hash ^= Version.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Manager.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Manager);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      if (Version.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Version);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Manager.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Manager);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      if (Version.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Version);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Manager.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Manager);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Version.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Version);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Package other) {
      if (other == null) {
        return;
      }
      if (other.Manager.Length != 0) {
        Manager = other.Manager;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Version.Length != 0) {
        Version = other.Version;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Manager = input.ReadString();
            break;
          }
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 26: {
            Version = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Manager = input.ReadString();
            break;
          }
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 26: {
            Version = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class SymbolDescriptor : pb::IMessage<SymbolDescriptor>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SymbolDescriptor> _parser = new pb::MessageParser<SymbolDescriptor>(() => new SymbolDescriptor());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SymbolDescriptor> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scip.ScipReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SymbolDescriptor() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SymbolDescriptor(SymbolDescriptor other) : this() {
      name_ = other.name_;
      disambiguator_ = other.disambiguator_;
      suffix_ = other.suffix_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SymbolDescriptor Clone() {
      return new SymbolDescriptor(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "disambiguator" field.</summary>
    public const int DisambiguatorFieldNumber = 2;
    private string disambiguator_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Disambiguator {
      get { return disambiguator_; }
      set {
        disambiguator_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "suffix" field.</summary>
    public const int SuffixFieldNumber = 3;
    private global::Scip.SymbolDescriptor.Types.Suffix suffix_ = global::Scip.SymbolDescriptor.Types.Suffix.UnspecifiedSuffix;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Scip.SymbolDescriptor.Types.Suffix Suffix {
      get { return suffix_; }
      set {
        suffix_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SymbolDescriptor);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SymbolDescriptor other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Disambiguator != other.Disambiguator) return false;
      if (Suffix != other.Suffix) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Disambiguator.Length != 0) hash ^= Disambiguator.GetHashCode();
      if (Suffix != global::Scip.SymbolDescriptor.Types.Suffix.UnspecifiedSuffix) hash ^= Suffix.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Disambiguator.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Disambiguator);
      }
      if (Suffix != global::Scip.SymbolDescriptor.Types.Suffix.UnspecifiedSuffix) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Suffix);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Disambiguator.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Disambiguator);
      }
      if (Suffix != global::Scip.SymbolDescriptor.Types.Suffix.UnspecifiedSuffix) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Suffix);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Disambiguator.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Disambiguator);
      }
      if (Suffix != global::Scip.SymbolDescriptor.Types.Suffix.UnspecifiedSuffix) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Suffix);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SymbolDescriptor other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Disambiguator.Length != 0) {
        Disambiguator = other.Disambiguator;
      }
      if (other.Suffix != global::Scip.SymbolDescriptor.Types.Suffix.UnspecifiedSuffix) {
        Suffix = other.Suffix;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Disambiguator = input.ReadString();
            break;
          }
          case 24: {
            Suffix = (global::Scip.SymbolDescriptor.Types.Suffix) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Disambiguator = input.ReadString();
            break;
          }
          case 24: {
            Suffix = (global::Scip.SymbolDescriptor.Types.Suffix) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the SymbolDescriptor message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum Suffix {
        [pbr::OriginalName("UnspecifiedSuffix")] UnspecifiedSuffix = 0,
        /// <summary>
        /// Unit of code abstraction and/or namespacing.
        ///
        /// NOTE: This corresponds to a package in Go and JVM languages.
        /// </summary>
        [pbr::OriginalName("Namespace")] Namespace = 1,
        /// <summary>
        /// Use Namespace instead.
        /// </summary>
        [pbr::OriginalName("Package", PreferredAlias = false)] Package = 1,
        [pbr::OriginalName("Type")] Type = 2,
        [pbr::OriginalName("Term")] Term = 3,
        [pbr::OriginalName("Method")] Method = 4,
        [pbr::OriginalName("TypeParameter")] TypeParameter = 5,
        [pbr::OriginalName("Parameter")] Parameter = 6,
        [pbr::OriginalName("Macro")] Macro = 9,
        /// <summary>
        /// Can be used for any purpose.
        /// </summary>
        [pbr::OriginalName("Meta")] Meta = 7,
        [pbr::OriginalName("Local")] Local = 8,
      }

    }
    #endregion

  }

  /// <summary>
  /// SymbolInformation defines metadata about a symbol, such as the symbol's
  /// docstring or what package it's defined it.
  /// </summary>
  public sealed partial class SymbolInformation : pb::IMessage<SymbolInformation>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SymbolInformation> _parser = new pb::MessageParser<SymbolInformation>(() => new SymbolInformation());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SymbolInformation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scip.ScipReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SymbolInformation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SymbolInformation(SymbolInformation other) : this() {
      symbol_ = other.symbol_;
      documentation_ = other.documentation_.Clone();
      relationships_ = other.relationships_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SymbolInformation Clone() {
      return new SymbolInformation(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private string symbol_ = "";
    /// <summary>
    /// Identifier of this symbol, which can be referenced from `Occurence.symbol`.
    /// The string must be formatted according to the grammar in `Symbol`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "documentation" field.</summary>
    public const int DocumentationFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_documentation_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> documentation_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// (optional, but strongly recommended) The markdown-formatted documentation
    /// for this symbol. This field is repeated to allow different kinds of
    /// documentation.  For example, it's nice to include both the signature of a
    /// method (parameters and return type) along with the accompanying docstring.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Documentation {
      get { return documentation_; }
    }

    /// <summary>Field number for the "relationships" field.</summary>
    public const int RelationshipsFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Scip.Relationship> _repeated_relationships_codec
        = pb::FieldCodec.ForMessage(34, global::Scip.Relationship.Parser);
    private readonly pbc::RepeatedField<global::Scip.Relationship> relationships_ = new pbc::RepeatedField<global::Scip.Relationship>();
    /// <summary>
    /// (optional) Relationships to other symbols (e.g., implements, type definition).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Scip.Relationship> Relationships {
      get { return relationships_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SymbolInformation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SymbolInformation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      if(!documentation_.Equals(other.documentation_)) return false;
      if(!relationships_.Equals(other.relationships_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      hash ^= documentation_.GetHashCode();
      hash ^= relationships_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      documentation_.WriteTo(output, _repeated_documentation_codec);
      relationships_.WriteTo(output, _repeated_relationships_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      documentation_.WriteTo(ref output, _repeated_documentation_codec);
      relationships_.WriteTo(ref output, _repeated_relationships_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      size += documentation_.CalculateSize(_repeated_documentation_codec);
      size += relationships_.CalculateSize(_repeated_relationships_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SymbolInformation other) {
      if (other == null) {
        return;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      documentation_.Add(other.documentation_);
      relationships_.Add(other.relationships_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 26: {
            documentation_.AddEntriesFrom(input, _repeated_documentation_codec);
            break;
          }
          case 34: {
            relationships_.AddEntriesFrom(input, _repeated_relationships_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 26: {
            documentation_.AddEntriesFrom(ref input, _repeated_documentation_codec);
            break;
          }
          case 34: {
            relationships_.AddEntriesFrom(ref input, _repeated_relationships_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class Relationship : pb::IMessage<Relationship>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Relationship> _parser = new pb::MessageParser<Relationship>(() => new Relationship());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Relationship> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scip.ScipReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Relationship() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Relationship(Relationship other) : this() {
      symbol_ = other.symbol_;
      isReference_ = other.isReference_;
      isImplementation_ = other.isImplementation_;
      isTypeDefinition_ = other.isTypeDefinition_;
      isDefinition_ = other.isDefinition_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Relationship Clone() {
      return new Relationship(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "is_reference" field.</summary>
    public const int IsReferenceFieldNumber = 2;
    private bool isReference_;
    /// <summary>
    /// When resolving "Find references", this field documents what other symbols
    /// should be included together with this symbol. For example, consider the
    /// following TypeScript code that defines two symbols `Animal#sound()` and
    /// `Dog#sound()`:
    /// ```ts
    /// interface Animal {
    ///           ^^^^^^ definition Animal#
    ///   sound(): string
    ///   ^^^^^ definition Animal#sound()
    /// }
    /// class Dog implements Animal {
    ///       ^^^ definition Dog#, implementation_symbols = Animal#
    ///   public sound(): string { return "woof" }
    ///          ^^^^^ definition Dog#sound(), references_symbols = Animal#sound(), implementation_symbols = Animal#sound()
    /// }
    /// const animal: Animal = new Dog()
    ///               ^^^^^^ reference Animal#
    /// console.log(animal.sound())
    ///                    ^^^^^ reference Animal#sound()
    /// ```
    /// Doing "Find references" on the symbol `Animal#sound()` should return
    /// references to the `Dog#sound()` method as well. Vice-versa, doing "Find
    /// references" on the `Dog#sound()` method should include references to the
    /// `Animal#sound()` method as well.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsReference {
      get { return isReference_; }
      set {
        isReference_ = value;
      }
    }

    /// <summary>Field number for the "is_implementation" field.</summary>
    public const int IsImplementationFieldNumber = 3;
    private bool isImplementation_;
    /// <summary>
    /// Similar to `references_symbols` but for "Go to implementation".
    /// It's common for the `implementation_symbols` and `references_symbols` fields
    /// have the same values but that's not always the case.
    /// In the TypeScript example above, observe that `implementation_symbols` has
    /// the value `"Animal#"` for the "Dog#" symbol while `references_symbols` is
    /// empty. When requesting "Find references" on the "Animal#" symbol we don't
    /// want to include references to "Dog#" even if "Go to implementation" on the
    /// "Animal#" symbol should navigate to the "Dog#" symbol.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsImplementation {
      get { return isImplementation_; }
      set {
        isImplementation_ = value;
      }
    }

    /// <summary>Field number for the "is_type_definition" field.</summary>
    public const int IsTypeDefinitionFieldNumber = 4;
    private bool isTypeDefinition_;
    /// <summary>
    /// Similar to `references_symbols` but for "Go to type definition".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsTypeDefinition {
      get { return isTypeDefinition_; }
      set {
        isTypeDefinition_ = value;
      }
    }

    /// <summary>Field number for the "is_definition" field.</summary>
    public const int IsDefinitionFieldNumber = 5;
    private bool isDefinition_;
    /// <summary>
    /// Allows overriding the behavior of "Go to definition" and "Find references"
    /// for symbols which do not have a definition of their own or could
    /// potentially have multiple definitions.
    ///
    /// For example, in a language with single inheritance and no field overriding,
    /// inherited fields can reuse the same symbol as the ancestor which declares
    /// the field. In such a situation, is_definition is not needed.
    ///
    /// On the other hand, in languages with single inheritance and some form
    /// of mixins, you can use is_definition to relate the symbol to the
    /// matching symbol in ancestor classes, and is_reference to relate the
    /// symbol to the matching symbol in mixins.
    ///
    /// NOTE: At the moment, due to limitations of the SCIP to LSIF conversion,
    /// only global symbols in an index are allowed to use is_definition.
    /// The relationship may not get recorded if either symbol is local.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsDefinition {
      get { return isDefinition_; }
      set {
        isDefinition_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Relationship);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Relationship other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      if (IsReference != other.IsReference) return false;
      if (IsImplementation != other.IsImplementation) return false;
      if (IsTypeDefinition != other.IsTypeDefinition) return false;
      if (IsDefinition != other.IsDefinition) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (IsReference != false) hash ^= IsReference.GetHashCode();
      if (IsImplementation != false) hash ^= IsImplementation.GetHashCode();
      if (IsTypeDefinition != false) hash ^= IsTypeDefinition.GetHashCode();
      if (IsDefinition != false) hash ^= IsDefinition.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (IsReference != false) {
        output.WriteRawTag(16);
        output.WriteBool(IsReference);
      }
      if (IsImplementation != false) {
        output.WriteRawTag(24);
        output.WriteBool(IsImplementation);
      }
      if (IsTypeDefinition != false) {
        output.WriteRawTag(32);
        output.WriteBool(IsTypeDefinition);
      }
      if (IsDefinition != false) {
        output.WriteRawTag(40);
        output.WriteBool(IsDefinition);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (IsReference != false) {
        output.WriteRawTag(16);
        output.WriteBool(IsReference);
      }
      if (IsImplementation != false) {
        output.WriteRawTag(24);
        output.WriteBool(IsImplementation);
      }
      if (IsTypeDefinition != false) {
        output.WriteRawTag(32);
        output.WriteBool(IsTypeDefinition);
      }
      if (IsDefinition != false) {
        output.WriteRawTag(40);
        output.WriteBool(IsDefinition);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (IsReference != false) {
        size += 1 + 1;
      }
      if (IsImplementation != false) {
        size += 1 + 1;
      }
      if (IsTypeDefinition != false) {
        size += 1 + 1;
      }
      if (IsDefinition != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Relationship other) {
      if (other == null) {
        return;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.IsReference != false) {
        IsReference = other.IsReference;
      }
      if (other.IsImplementation != false) {
        IsImplementation = other.IsImplementation;
      }
      if (other.IsTypeDefinition != false) {
        IsTypeDefinition = other.IsTypeDefinition;
      }
      if (other.IsDefinition != false) {
        IsDefinition = other.IsDefinition;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            IsReference = input.ReadBool();
            break;
          }
          case 24: {
            IsImplementation = input.ReadBool();
            break;
          }
          case 32: {
            IsTypeDefinition = input.ReadBool();
            break;
          }
          case 40: {
            IsDefinition = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            IsReference = input.ReadBool();
            break;
          }
          case 24: {
            IsImplementation = input.ReadBool();
            break;
          }
          case 32: {
            IsTypeDefinition = input.ReadBool();
            break;
          }
          case 40: {
            IsDefinition = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Occurrence associates a source position with a symbol and/or highlighting
  /// information.
  ///
  /// If possible, indexers should try to bundle logically related information
  /// across occurrences into a single occurrence to reduce payload sizes.
  /// </summary>
  public sealed partial class Occurrence : pb::IMessage<Occurrence>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Occurrence> _parser = new pb::MessageParser<Occurrence>(() => new Occurrence());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Occurrence> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scip.ScipReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Occurrence() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Occurrence(Occurrence other) : this() {
      range_ = other.range_.Clone();
      symbol_ = other.symbol_;
      symbolRoles_ = other.symbolRoles_;
      overrideDocumentation_ = other.overrideDocumentation_.Clone();
      syntaxKind_ = other.syntaxKind_;
      diagnostics_ = other.diagnostics_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Occurrence Clone() {
      return new Occurrence(this);
    }

    /// <summary>Field number for the "range" field.</summary>
    public const int RangeFieldNumber = 1;
    private static readonly pb::FieldCodec<int> _repeated_range_codec
        = pb::FieldCodec.ForInt32(10);
    private readonly pbc::RepeatedField<int> range_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// Source position of this occurrence. Must be exactly three or four
    /// elements:
    ///
    /// - Four elements: `[startLine, startCharacter, endLine, endCharacter]`
    /// - Three elements: `[startLine, startCharacter, endCharacter]`. The end line
    ///   is inferred to have the same value as the start line.
    ///
    /// Line numbers and characters are always 0-based. Make sure to increment the
    /// line/character values before displaying them in an editor-like UI because
    /// editors conventionally use 1-based numbers.
    ///
    /// Historical note: the original draft of this schema had a `Range` message
    /// type with `start` and `end` fields of type `Position`, mirroring LSP.
    /// Benchmarks revealed that this encoding was inefficient and that we could
    /// reduce the total payload size of an index by 50% by using `repeated int32`
    /// instead.  The `repeated int32` encoding is admittedly more embarrassing to
    /// work with in some programming languages but we hope the performance
    /// improvements make up for it.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> Range {
      get { return range_; }
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 2;
    private string symbol_ = "";
    /// <summary>
    /// (optional) The symbol that appears at this position. See
    /// `SymbolInformation.symbol` for how to format symbols as strings.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "symbol_roles" field.</summary>
    public const int SymbolRolesFieldNumber = 3;
    private int symbolRoles_;
    /// <summary>
    /// (optional) Bitset containing `SymbolRole`s in this occurrence.
    /// See `SymbolRole`'s documentation for how to read and write this field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int SymbolRoles {
      get { return symbolRoles_; }
      set {
        symbolRoles_ = value;
      }
    }

    /// <summary>Field number for the "override_documentation" field.</summary>
    public const int OverrideDocumentationFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_overrideDocumentation_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> overrideDocumentation_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// (optional) CommonMark-formatted documentation for this specific range. If
    /// empty, the `Symbol.documentation` field is used instead. One example
    /// where this field might be useful is when the symbol represents a generic
    /// function (with abstract type parameters such as `List&lt;T>`) and at this
    /// occurrence we know the exact values (such as `List&lt;String>`).
    ///
    /// This field can also be used for dynamically or gradually typed languages,
    /// which commonly allow for type-changing assignment.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> OverrideDocumentation {
      get { return overrideDocumentation_; }
    }

    /// <summary>Field number for the "syntax_kind" field.</summary>
    public const int SyntaxKindFieldNumber = 5;
    private global::Scip.SyntaxKind syntaxKind_ = global::Scip.SyntaxKind.UnspecifiedSyntaxKind;
    /// <summary>
    /// (optional) What syntax highlighting class should be used for this range?
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Scip.SyntaxKind SyntaxKind {
      get { return syntaxKind_; }
      set {
        syntaxKind_ = value;
      }
    }

    /// <summary>Field number for the "diagnostics" field.</summary>
    public const int DiagnosticsFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Scip.Diagnostic> _repeated_diagnostics_codec
        = pb::FieldCodec.ForMessage(50, global::Scip.Diagnostic.Parser);
    private readonly pbc::RepeatedField<global::Scip.Diagnostic> diagnostics_ = new pbc::RepeatedField<global::Scip.Diagnostic>();
    /// <summary>
    /// (optional) Diagnostics that have been reported for this specific range.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Scip.Diagnostic> Diagnostics {
      get { return diagnostics_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Occurrence);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Occurrence other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!range_.Equals(other.range_)) return false;
      if (Symbol != other.Symbol) return false;
      if (SymbolRoles != other.SymbolRoles) return false;
      if(!overrideDocumentation_.Equals(other.overrideDocumentation_)) return false;
      if (SyntaxKind != other.SyntaxKind) return false;
      if(!diagnostics_.Equals(other.diagnostics_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= range_.GetHashCode();
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (SymbolRoles != 0) hash ^= SymbolRoles.GetHashCode();
      hash ^= overrideDocumentation_.GetHashCode();
      if (SyntaxKind != global::Scip.SyntaxKind.UnspecifiedSyntaxKind) hash ^= SyntaxKind.GetHashCode();
      hash ^= diagnostics_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      range_.WriteTo(output, _repeated_range_codec);
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (SymbolRoles != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(SymbolRoles);
      }
      overrideDocumentation_.WriteTo(output, _repeated_overrideDocumentation_codec);
      if (SyntaxKind != global::Scip.SyntaxKind.UnspecifiedSyntaxKind) {
        output.WriteRawTag(40);
        output.WriteEnum((int) SyntaxKind);
      }
      diagnostics_.WriteTo(output, _repeated_diagnostics_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      range_.WriteTo(ref output, _repeated_range_codec);
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (SymbolRoles != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(SymbolRoles);
      }
      overrideDocumentation_.WriteTo(ref output, _repeated_overrideDocumentation_codec);
      if (SyntaxKind != global::Scip.SyntaxKind.UnspecifiedSyntaxKind) {
        output.WriteRawTag(40);
        output.WriteEnum((int) SyntaxKind);
      }
      diagnostics_.WriteTo(ref output, _repeated_diagnostics_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += range_.CalculateSize(_repeated_range_codec);
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (SymbolRoles != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(SymbolRoles);
      }
      size += overrideDocumentation_.CalculateSize(_repeated_overrideDocumentation_codec);
      if (SyntaxKind != global::Scip.SyntaxKind.UnspecifiedSyntaxKind) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SyntaxKind);
      }
      size += diagnostics_.CalculateSize(_repeated_diagnostics_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Occurrence other) {
      if (other == null) {
        return;
      }
      range_.Add(other.range_);
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.SymbolRoles != 0) {
        SymbolRoles = other.SymbolRoles;
      }
      overrideDocumentation_.Add(other.overrideDocumentation_);
      if (other.SyntaxKind != global::Scip.SyntaxKind.UnspecifiedSyntaxKind) {
        SyntaxKind = other.SyntaxKind;
      }
      diagnostics_.Add(other.diagnostics_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            range_.AddEntriesFrom(input, _repeated_range_codec);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
          case 24: {
            SymbolRoles = input.ReadInt32();
            break;
          }
          case 34: {
            overrideDocumentation_.AddEntriesFrom(input, _repeated_overrideDocumentation_codec);
            break;
          }
          case 40: {
            SyntaxKind = (global::Scip.SyntaxKind) input.ReadEnum();
            break;
          }
          case 50: {
            diagnostics_.AddEntriesFrom(input, _repeated_diagnostics_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10:
          case 8: {
            range_.AddEntriesFrom(ref input, _repeated_range_codec);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
          case 24: {
            SymbolRoles = input.ReadInt32();
            break;
          }
          case 34: {
            overrideDocumentation_.AddEntriesFrom(ref input, _repeated_overrideDocumentation_codec);
            break;
          }
          case 40: {
            SyntaxKind = (global::Scip.SyntaxKind) input.ReadEnum();
            break;
          }
          case 50: {
            diagnostics_.AddEntriesFrom(ref input, _repeated_diagnostics_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents a diagnostic, such as a compiler error or warning, which should be
  /// reported for a document.
  /// </summary>
  public sealed partial class Diagnostic : pb::IMessage<Diagnostic>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Diagnostic> _parser = new pb::MessageParser<Diagnostic>(() => new Diagnostic());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Diagnostic> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scip.ScipReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Diagnostic() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Diagnostic(Diagnostic other) : this() {
      severity_ = other.severity_;
      code_ = other.code_;
      message_ = other.message_;
      source_ = other.source_;
      tags_ = other.tags_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Diagnostic Clone() {
      return new Diagnostic(this);
    }

    /// <summary>Field number for the "severity" field.</summary>
    public const int SeverityFieldNumber = 1;
    private global::Scip.Severity severity_ = global::Scip.Severity.UnspecifiedSeverity;
    /// <summary>
    /// Should this diagnostic be reported as an error, warning, info, or hint?
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Scip.Severity Severity {
      get { return severity_; }
      set {
        severity_ = value;
      }
    }

    /// <summary>Field number for the "code" field.</summary>
    public const int CodeFieldNumber = 2;
    private string code_ = "";
    /// <summary>
    /// (optional) Code of this diagnostic, which might appear in the user interface.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Code {
      get { return code_; }
      set {
        code_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 3;
    private string message_ = "";
    /// <summary>
    /// Message of this diagnostic.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Message {
      get { return message_; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "source" field.</summary>
    public const int SourceFieldNumber = 4;
    private string source_ = "";
    /// <summary>
    /// (optional) Human-readable string describing the source of this diagnostic, e.g.
    /// 'typescript' or 'super lint'.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Source {
      get { return source_; }
      set {
        source_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "tags" field.</summary>
    public const int TagsFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Scip.DiagnosticTag> _repeated_tags_codec
        = pb::FieldCodec.ForEnum(42, x => (int) x, x => (global::Scip.DiagnosticTag) x);
    private readonly pbc::RepeatedField<global::Scip.DiagnosticTag> tags_ = new pbc::RepeatedField<global::Scip.DiagnosticTag>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Scip.DiagnosticTag> Tags {
      get { return tags_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Diagnostic);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Diagnostic other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Severity != other.Severity) return false;
      if (Code != other.Code) return false;
      if (Message != other.Message) return false;
      if (Source != other.Source) return false;
      if(!tags_.Equals(other.tags_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Severity != global::Scip.Severity.UnspecifiedSeverity) hash ^= Severity.GetHashCode();
      if (Code.Length != 0) hash ^= Code.GetHashCode();
      if (Message.Length != 0) hash ^= Message.GetHashCode();
      if (Source.Length != 0) hash ^= Source.GetHashCode();
      hash ^= tags_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Severity != global::Scip.Severity.UnspecifiedSeverity) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Severity);
      }
      if (Code.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Code);
      }
      if (Message.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Message);
      }
      if (Source.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Source);
      }
      tags_.WriteTo(output, _repeated_tags_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Severity != global::Scip.Severity.UnspecifiedSeverity) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Severity);
      }
      if (Code.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Code);
      }
      if (Message.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Message);
      }
      if (Source.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Source);
      }
      tags_.WriteTo(ref output, _repeated_tags_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Severity != global::Scip.Severity.UnspecifiedSeverity) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Severity);
      }
      if (Code.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Code);
      }
      if (Message.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (Source.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Source);
      }
      size += tags_.CalculateSize(_repeated_tags_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Diagnostic other) {
      if (other == null) {
        return;
      }
      if (other.Severity != global::Scip.Severity.UnspecifiedSeverity) {
        Severity = other.Severity;
      }
      if (other.Code.Length != 0) {
        Code = other.Code;
      }
      if (other.Message.Length != 0) {
        Message = other.Message;
      }
      if (other.Source.Length != 0) {
        Source = other.Source;
      }
      tags_.Add(other.tags_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Severity = (global::Scip.Severity) input.ReadEnum();
            break;
          }
          case 18: {
            Code = input.ReadString();
            break;
          }
          case 26: {
            Message = input.ReadString();
            break;
          }
          case 34: {
            Source = input.ReadString();
            break;
          }
          case 42:
          case 40: {
            tags_.AddEntriesFrom(input, _repeated_tags_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Severity = (global::Scip.Severity) input.ReadEnum();
            break;
          }
          case 18: {
            Code = input.ReadString();
            break;
          }
          case 26: {
            Message = input.ReadString();
            break;
          }
          case 34: {
            Source = input.ReadString();
            break;
          }
          case 42:
          case 40: {
            tags_.AddEntriesFrom(ref input, _repeated_tags_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
